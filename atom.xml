<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haozhe Zhu&#39;s Blog</title>
  
  
  <link href="https://zhutmost.com/atom.xml" rel="self"/>
  
  <link href="https://zhutmost.com/"/>
  <updated>2023-09-22T15:57:32.812Z</updated>
  <id>https://zhutmost.com/</id>
  
  <author>
    <name>Haozhe Zhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2024年智能芯片领域会议概览</title>
    <link href="https://zhutmost.com/Research/asic-conf-ddl-2024/"/>
    <id>https://zhutmost.com/Research/asic-conf-ddl-2024/</id>
    <published>2023-08-14T06:31:19.000Z</published>
    <updated>2023-09-22T15:57:32.812Z</updated>
    
    <content type="html"><![CDATA[<p>为了准确把握每一个学术交流（摸鱼）的机会，本文收集了 2024 年智能芯片领域（固态电路、体系结构等）的相关学术会议的投稿信息，包括召开时间、地点、截稿时间等。</p><span id="more"></span><p><strong>历史版本</strong>：</p><ul><li><a href="https://zhutmost.com/Research/asic-conf-ddl-2023">2023年智能芯片领域会议概览</a></li></ul><p>由于多数会议的投稿截稿时间都会延期一至两周，因此下表中的截稿时间通常只是个大约时间。表中空白位置是还没有公布的信息，我会继续更新。</p><h2 id="固态电路"><a href="#固态电路" class="headerlink" title="固态电路"></a>固态电路</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">ISSCC</td><td>San Francisco, CA, US</td><td>2024.02.18</td><td>2023.09.06</td><td><a href="https://www.isscc.org/">Link</a></td></tr><tr><td align="center">VLSI</td><td>Honolulu, HI USA</td><td>2024.06.12</td><td></td><td><a href="https://www.vlsisymposium.org/">Link</a></td></tr><tr><td align="center">ESSERC*</td><td>Bruges, Belgium</td><td>2024.09.09</td><td>2024.04.05</td><td><a href="https://www.esserc2024.org/">Link</a></td></tr><tr><td align="center">ASSCC</td><td></td><td></td><td></td><td></td></tr><tr><td align="center">CICC</td><td>Denver, CO, US</td><td>2024.04.21</td><td>2023.11.06</td><td><a href="https://www.ieee-cicc.org/">Link</a></td></tr><tr><td align="center">HOTCHIPS</td><td></td><td></td><td></td><td><a href="https://hotchips.org/">Link</a></td></tr></tbody></table><blockquote><p>* 欧洲固态电路会议（ESSCIRC）和欧洲固态器件研究会议（ESSDERC）从 2024 年起合并为欧洲固态电子研究会议（ESSERC）。</p></blockquote><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">ISCA</td><td>Buenos Aires, Argentina</td><td>2024.06.29</td><td>2023.11.14</td><td><a href="https://iscaconf.org/isca2024/">Link</a></td></tr><tr><td align="center">MICRO</td><td></td><td></td><td></td><td><a href="https://microarch.org/">Link</a></td></tr><tr><td align="center">HPCA</td><td>Edinburgh, Scotland</td><td>2024.03.02</td><td>2023.07.28</td><td><a href="https://hpca-conf.org/2024">Link</a></td></tr><tr><td align="center">DAC</td><td>San Francisco, CA, US</td><td>2024.06.23</td><td></td><td><a href="https://www.dac.com/">Link</a></td></tr></tbody></table><h2 id="机器视觉"><a href="#机器视觉" class="headerlink" title="机器视觉"></a>机器视觉</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">CVPR</td><td>Seattle, WA, US</td><td>2024.06.17</td><td>2023.11.03</td><td><a href="https://cvpr2023.thecvf.com/Conferences/2024">Link</a></td></tr><tr><td align="center">IROS</td><td></td><td></td><td></td><td><a href="https://ieee-iros.org/">Link</a></td></tr><tr><td align="center">ICRA</td><td>Yokohama, Japan</td><td>2024.05.13</td><td>2023.09.15</td><td><a href="https://2024.ieee-icra.org/">Link</a></td></tr></tbody></table><h2 id="其他会议"><a href="#其他会议" class="headerlink" title="其他会议"></a>其他会议</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">ISCAS</td><td>Singapore</td><td>2024.05.19</td><td>2023.10.15</td><td><a href="https://2024.ieee-iscas.org/">Link</a></td></tr><tr><td align="center">AICAS</td><td>Dubai, UAE</td><td>2024.04.15</td><td>2023.10.15</td><td><a href="http://www.aicas2024.org/">Link</a></td></tr><tr><td align="center">APCCAS</td><td>Taipei, Taiwan</td><td>2024.11.07</td><td></td><td><a href="https://ieee-cas.org/event/conference/2024-ieee-asia-pacific-conference-circuits-and-systems">Link</a></td></tr><tr><td align="center">MWSCAS</td><td>Western Springfield, MA, US</td><td>2024.08.11</td><td>2024.03.22</td><td><a href="https://www.mwscas2024.org/">Link</a></td></tr><tr><td align="center">BioCAS</td><td></td><td></td><td></td><td><a href="https://2023.ieee-biocas.org/">Link</a></td></tr><tr><td align="center">GLSVLSI</td><td></td><td></td><td></td><td><a href="https://www.glsvlsi.org/">Link</a></td></tr><tr><td align="center">ICCAD</td><td></td><td></td><td></td><td><a href="https://iccad.com/">Link</a></td></tr><tr><td align="center">ASP-DAC</td><td>Incheon, South Korea</td><td>2024.01.22</td><td>2023.07.28</td><td><a href="https://www.aspdac.com/">Link</a></td></tr><tr><td align="center">DATE</td><td>Valencia, Spain</td><td>2024.03.25</td><td>2023.09.10</td><td><a href="https://www.date-conference.com/">Link</a></td></tr><tr><td align="center">FPGA</td><td>Monterey, CA, US</td><td>2024.03.03</td><td>2023.10.13</td><td><a href="https://www.isfpga.org/">Link</a></td></tr></tbody></table><p>祝大家投稿顺利～</p><p><a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-size:12px;line-height:1.2;display:inline-block;border-radius:3px" href="https://unsplash.com" target="_blank" rel="noopener noreferrer" title="unsplash"><span style="display:inline-block;padding:2px 3px"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white" viewBox="0 0 32 32"><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px">photoed by Birmingham Museums</span></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了准确把握每一个学术交流（摸鱼）的机会，本文收集了 2024 年智能芯片领域（固态电路、体系结构等）的相关学术会议的投稿信息，包括召开时间、地点、截稿时间等。&lt;/p&gt;</summary>
    
    
    
    <category term="Research" scheme="https://zhutmost.com/categories/Research/"/>
    
    
    <category term="Paper Lives Matter" scheme="https://zhutmost.com/tags/Paper-Lives-Matter/"/>
    
    <category term="AI Chip" scheme="https://zhutmost.com/tags/AI-Chip/"/>
    
  </entry>
  
  <entry>
    <title>🐿️ Chipmunk Docs - DecoupledIO 增强版之 StreamIO</title>
    <link href="https://zhutmost.com/Engineering/chipmunk-stream/"/>
    <id>https://zhutmost.com/Engineering/chipmunk-stream/</id>
    <published>2023-08-09T06:07:49.239Z</published>
    <updated>2023-08-16T11:31:29.332Z</updated>
    
    <content type="html"><![CDATA[<p>在数字电路设计中，我们经常使用 Ready&#x2F;Valid 握手协议来解耦数据流，Chisel 提供了 <code>DecoupledIO</code> 用以实现这一协议。然而，<code>DecoupledIO</code> 仅是一个预置的 <code>Bundle</code>，缺少与之配套的一系列常用组件（例如寄存器切片、Mux&#x2F;Demux 等），此外它也未能搭配 <code>chipmunk.IsMasterSlave</code>。<code>chipmunk</code> 为 <code>DecoupledIO</code> 提供了一个“威力加强版”的 Ready&#x2F;Valid 握手协议——<code>chipmunk.StreamIO</code>。</p><span id="more"></span><h2 id="Ready-Valid-握手协议"><a href="#Ready-Valid-握手协议" class="headerlink" title="Ready&#x2F;Valid 握手协议"></a>Ready&#x2F;Valid 握手协议</h2><img src="/Engineering/chipmunk-stream/ready-valid-protocol.png" class="" title="Ready&#x2F;Valid Interface"><p>Ready&#x2F;Valid 握手协议由三部分信号组成：</p><ul><li><code>valid</code>：表示数据有效，即上游数据已经准备好，可以被消费；</li><li><code>ready</code>：表示数据可被消费，即下游已经准备好接收数据；</li><li><code>bits</code>（即 <code>payload</code>）：表示数据本身。</li></ul><p>其中，<code>valid</code> 和 <code>bits</code> 信号由上游产生，<code>ready</code> 信号由下游产生。当 <code>valid</code> 和 <code>ready</code> 信号同时有效时，<code>bits</code> 信号被传递，即数据被消费。利用这一协议，我们可以将数据流的生产和消费解耦：上游模块只需要在准备好数据后将 <code>valid</code> 和 <code>bits</code> 信号置为有效，而无需关心下游模块内部的状态；而下游模块只需要在准备好接收数据后将 <code>ready</code> 信号置为有效，当 <code>valid</code> 和 <code>ready</code> 信号同时有效时取走 <code>bits</code> 数据。通过使用 Ready&#x2F;Valid 握手协议，开发者可以将注意力集中在自己负责的电路逻辑上，而无需过度关心其他模块的内部实现，从而提高开发效率。</p><p>需要注意的是，为了避免组合逻辑环路，我们要求 <code>valid</code>（及 <code>bits</code>）和 <code>ready</code> 信号不能同时依赖对方的当前状态。因此，在 Chipmunk（和其他绝大多数数字电路设计）中，我们约定 <code>valid</code> 不允许依赖于 <code>ready</code> 的当前状态，即上游模块不允许根据下游模块此刻是否 <code>ready</code> 来决定当前周期是否将 <code>valid</code> 置为有效。简单地说，用于 <code>valid</code> 产生的组合逻辑表达式中不能出现下游模块的 <code>ready</code> 信号。</p><p>关于 Ready&#x2F;Valid 握手协议的更多细节，网上已经有了丰富的材料可以参考，这里不再赘述。</p><h2 id="关于-StreamIO"><a href="#关于-StreamIO" class="headerlink" title="关于 StreamIO"></a>关于 <code>StreamIO</code></h2><h3 id="Why"><a href="#Why" class="headerlink" title="Why?"></a>Why?</h3><p>Chisel 提供了 <code>DecoupledIO</code> 和 <code>IrrevocableIO</code> 两个 Ready&#x2F;Valid 握手协议的 <code>Bundle</code> 实现，它们都继承自 <code>chisel3.ReadyValidIO</code>。Chisel 并未为这两个接口提供太多 API，基本上只有：</p><ul><li><code>def fire: Bool = ready &amp;&amp; valid</code>，表示当前周期是否发生了数据传输；</li><li><code>class Queue</code>，以 <code>ReadyValidIO</code> 为接口的同步 FIFO；</li><li><code>def map[T](f: T =&gt; T2): T</code>，用于对 <code>bits</code> 进行变换。</li></ul><p><code>IrrevocableIO</code> 其实在实现上 <code>DecoupledIO</code> 并无区别，只是约定它的 <code>bits</code> 在 <code>valid</code> 有效但 <code>ready</code> 无效时不会改变，即数据不可撤回。两者的实际差别有赖于具体模块中的电路实现。</p><p>很显然，上述 API 不足以应付实际的设计需求。</p><p>Chipmunk 在 <code>chisel3.ReadyValidIO</code> 的基础上提供了 <code>chipmunk.StreamIO</code>，它继承自 <code>chisel3.ReadyValidIO</code>，并提供了一系列常用的 API 和特性，包括：</p><ul><li>一系列类似<code>fire</code> 的语法糖，展现数据传输的不同状态；</li><li>符号化的连接方法，类似 <code>a &gt;&gt; b &gt;-&gt; c</code>，可以很容易地看出数据的流向；</li><li>针对 <code>bits</code> 的一系列操作，包括 Map、Cast 等；</li><li>一系列常用的组件，包括寄存器切片（Register Slice）、Fork&#x2F;Join、Mux&#x2F;Demux 等。</li></ul><p><code>StreamIO</code> 在实现上参考了 <a href="https://spinalhdl.github.io/SpinalDoc-RTD/master/SpinalHDL/Libraries/stream.html">SpinalHDL</a> 的 <code>Stream</code> 的 API 设计，熟悉 SpinalHDL 的同学应该会有一丝熟悉的感觉。</p><h3 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h3><h4 id="StreamIO-例化"><a href="#StreamIO-例化" class="headerlink" title="StreamIO 例化"></a>StreamIO 例化</h4><ul><li><p>创建一个 <code>StreamIO</code>，其 <code>payload</code> 类型为 <code>UInt</code>：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myStream = <span class="type">Wire</span>(<span class="type">Stream</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>)))</span><br></pre></td></tr></table></figure></li><li><p>创建一个 <code>StreamIO</code>，其 <code>payload</code> 类型和另一个 <code>DecoupledIO</code> 的 <code>bits</code> 一致：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myDecoupled = <span class="type">Wire</span>(<span class="type">Decoupled</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>)))</span><br><span class="line"><span class="keyword">val</span> myStream = <span class="type">Wire</span>(<span class="type">Stream</span>(myDecoupled))</span><br></pre></td></tr></table></figure><p>请注意这里 <code>myStream</code> 不会与 <code>myDecoupled</code> 有任何电路连接（比如共享 <code>bits</code>），而是会创建一个新的 <code>UInt</code> 作为 <code>payload</code>。</p></li><li><p>创建一个空的 <code>StreamIO</code>（即其 <code>payload</code> 类型为 <code>EmptyBundle</code>）：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> myStream = <span class="type">Wire</span>(<span class="type">Stream</span>.empty)</span><br></pre></td></tr></table></figure><p>空的 <code>StreamIO</code> 一般用于声明时没有确定 <code>payload</code> 类型的情况，后续可以搭配 <code>payloadReplace</code> 等 API 赋予具体的 <code>payload</code>。</p></li></ul><h4 id="流控与状态指示"><a href="#流控与状态指示" class="headerlink" title="流控与状态指示"></a>流控与状态指示</h4><p><code>StreamIO</code> 提供以下状态指示方法，它们的返回类型均为 <code>Bool</code>：</p><table><thead><tr><th align="left">语法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>x.fire</code></td><td align="left">当前周期正在进行数据传输，即 <code>ready &amp;&amp; valid</code></td></tr><tr><td align="left"><code>x.isPending</code></td><td align="left">上游数据已经就绪，但下游未能准备好接收，即 <code>!ready &amp;&amp; valid</code></td></tr><tr><td align="left"><code>x.isStarving</code></td><td align="left">下游已准备好接收数据，但上游没有发起传输，即 <code>ready &amp;&amp; !valid</code></td></tr></tbody></table><p><code>StreamIO</code> 也提供下列方法对数据流进行流控，它们会返回一个新的 <code>StreamIO</code>：</p><table><thead><tr><th align="left">语法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>x.haltWhen(cond)</code></td><td align="left">当 <code>cond</code> 为 <code>True</code> 时，数据传输会被阻断，即上下游模块均无法完成握手。</td></tr><tr><td align="left"><code>x.continueWhen(cond)</code></td><td align="left">相当于 <code>x.haltWhen(!cond)</code></td></tr><tr><td align="left"><code>x.throwWhen(cond)</code></td><td align="left">当 <code>cond</code> 为 <code>True</code> 时，数据传输会被丢弃，即上游模块发起的数据传输都会成功握手，但下游模块不会收到相应的数据。</td></tr><tr><td align="left"><code>x.takeWhen(cond)</code></td><td align="left">相当于 <code>x.throwWhen(!cond)</code></td></tr></tbody></table><h4 id="Payload-变换"><a href="#Payload-变换" class="headerlink" title="Payload 变换"></a>Payload 变换</h4><img src="/Engineering/chipmunk-stream/stream-payload-operation.png" class="" title="StreamIO Payload Operation"><p><code>StreamIO</code> 允许对 <code>payload</code> 直接进行一系列变换，包括：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payloadMap</span></span>[<span class="type">T2</span> &lt;: <span class="type">Data</span>](f: <span class="type">T</span> =&gt; <span class="type">T2</span>): <span class="type">StreamIO</span>[<span class="type">T2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payloadReplace</span></span>[<span class="type">T2</span> &lt;: <span class="type">Data</span>](p: <span class="type">T2</span>): <span class="type">StreamIO</span>[<span class="type">T2</span>]</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">payloadCast</span></span>[<span class="type">T2</span> &lt;: <span class="type">Data</span>](gen: <span class="type">T2</span>, checkWidth: <span class="type">Boolean</span> = <span class="literal">false</span>): <span class="type">StreamIO</span>[<span class="type">T2</span>]</span><br></pre></td></tr></table></figure><p>上述方法会返回一个新的 <code>StreamIO</code>，其 <code>payload</code> 会变成变换后、类型为 <code>T2</code> 的新信号，同时其 <code>ready</code> 和 <code>valid</code> 信号会连接到当前 <code>StreamIO</code> 的 <code>ready</code> 和 <code>valid</code> 信号。</p><ul><li><p><code>payloadMap</code> 可以将函数 <code>f</code> 作用于 <code>payload</code>，比如：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamOld = <span class="type">Wire</span>(<span class="type">Stream</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>)))</span><br><span class="line"><span class="keyword">val</span> <span class="type">StreamNew</span> = streamOld.payloadMap(_ + <span class="number">1.</span><span class="type">U</span>)</span><br></pre></td></tr></table></figure></li><li><p><code>payloadReplace</code> 会将 <code>payload</code> 替换为 <code>p</code>，相当于 <code>payloadMap(_ =&gt; p)</code>，比如：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamOld = <span class="type">Wire</span>(<span class="type">Stream</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>)))</span><br><span class="line"><span class="keyword">val</span> anotherBool = <span class="type">Wire</span>(<span class="type">Bool</span>())</span><br><span class="line"><span class="keyword">val</span> <span class="type">StreamNew</span> = streamOld.payloadReplace(anotherBool)</span><br></pre></td></tr></table></figure></li><li><p><code>payloadCast</code> 会对 <code>payload</code> 进行强制类型转换，相当于 <code>payloadMap(_.asTypeOf(gen))</code>，比如：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamOld = <span class="type">Wire</span>(<span class="type">Stream</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>)))</span><br><span class="line"><span class="keyword">val</span> <span class="type">StreamNew</span> = streamOld.payloadCast(<span class="type">SInt</span>(<span class="number">32.</span><span class="type">W</span>), checkWidth = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>其中参数 <code>checkWidth = true</code> 允许检查类型转换前后的位宽是否一致，如果不一致抛出异常。该参数默认为 <code>false</code>，即不会检查位宽，如果位宽不一致会自动截断或扩展。</p></li></ul><h4 id="寄存器切片（Register-Slice）"><a href="#寄存器切片（Register-Slice）" class="headerlink" title="寄存器切片（Register Slice）"></a>寄存器切片（Register Slice）</h4><p>为 <code>StreamIO</code> 插入寄存器切片以改善时序，是一个常见的需求。然而，这实现起来非常繁琐且易错。显然，我们不能直接在 <code>StreamIO</code> 的 <code>ready</code>&#x2F;<code>valid</code>&#x2F;<code>bits</code> 路径上贸然插入寄存器切片。<code>valid</code> 和 <code>ready</code> 分别代表当前周期上游模块和下游模块的状态，在它们的传播通路上引入寄存器会导致状态延后若干周期才会传播到对侧。这会导致上下游模块无法在正确的时机完成握手，可能会引起数据丢失或吞吐下降。</p><p>根据寄存器插入位置不同，<code>StreamIO</code> 提供：</p><ul><li><code>pipeForward</code>：前向寄存器切片，切断从上游模块到下游模块的 <code>valid</code> 和 <code>bits</code> 通路的组合逻辑路径；<figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamNew = streamOld.pipeForward()</span><br></pre></td></tr></table></figure>它在性能上不会引入吞吐下降（虽然会增加 1 周期延时），在面积上代价是 N + 1 个寄存器（N 是 <code>bits</code> 位宽）以及少量组合逻辑。</li><li><code>pipeBackward</code>：后向寄存器切片，切断从下游模块到上游模块的 <code>ready</code> 通路的组合逻辑路径。<figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamNew = streamOld.pipeBackward()</span><br></pre></td></tr></table></figure>它在性能上不会引入额外的延时和吞吐下降，在面积上代价是 N + 1 个寄存器（N 是 <code>bits</code> 位宽）、N 个 2:1 MUX 以及少量组合逻辑。</li><li><code>pipeAll</code>：双向寄存器切片，同时切断 <code>valid</code>、<code>bits</code>、<code>ready</code> 通路的组合逻辑路径。<figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamNew = streamOld.pipeAll()</span><br></pre></td></tr></table></figure>相当于 <code>streamOld.pipeForward().pipeBackward()</code>，因此它会引入 2N + 2 个寄存器（N 是 <code>bits</code> 位宽）、N 个 2:1 MUX 以及少量组合逻辑。</li><li><code>pipeSimple</code>：双向寄存器切片，同时切断 <code>valid</code>、<code>bits</code>、<code>ready</code> 通路的组合逻辑路径。<figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamNew = streamOld.pipeSimple()</span><br></pre></td></tr></table></figure>它至多每隔一个周期握手一次，因此会引起最高可达一半的吞吐损失，但面积上只需要 N + 2 个寄存器以及少量的组合逻辑。与 <code>pipeAll</code> 相比，它的面积代价更小，但会引入额外的性能损失。</li><li><code>pipeValid</code>：仅切断 <code>valid</code> 通路的组合逻辑路径。<figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamNew = streamOld.pipeValid()</span><br></pre></td></tr></table></figure>面积上仅需要 1 个寄存器和少量组合逻辑。</li><li><code>pipPassThrough</code>：什么都不做，返回当前的 <code>StreamIO</code>。<figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> streamNew = streamOld.pipPassThrough()</span><br></pre></td></tr></table></figure></li></ul><h4 id="符号化连接"><a href="#符号化连接" class="headerlink" title="符号化连接"></a>符号化连接</h4><p><code>StreamIO</code> 提供了一系列方法用于连接其他 <code>StreamIO</code>：</p><table><thead><tr><th align="left">语法</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>x.connectFrom(y)</code></td><td align="left">用 <code>y</code> 驱动 <code>x</code>，即 <code>y</code> 作为 <code>x</code> 的上游进行连接 <code>ready</code>、<code>valid</code>、<code>bits</code> 信号</td></tr><tr><td align="left"><code>x.handshakeFrom(y)</code></td><td align="left">和 <code>connectFrom</code> 类似，但只连接 <code>ready</code>、<code>valid</code> 信号，不连接 <code>bits</code> 信号</td></tr><tr><td align="left"><code>x &lt;&lt; y</code></td><td align="left">相当于 <code>x.connectFrom(y)</code>，返回 <code>y</code></td></tr><tr><td align="left"><code>x &gt;&gt; y</code></td><td align="left">相当于 <code>y.connectFrom(x)</code>，返回 <code>y</code></td></tr><tr><td align="left"><code>x &lt;-&lt; y</code></td><td align="left">相当于 <code>x &lt;&lt; y.pipeForward()</code>，返回 <code>y</code></td></tr><tr><td align="left"><code>x &gt;-&gt; y</code></td><td align="left">相当于 <code>x.pipeForward() &gt;&gt; y</code>，返回 <code>y</code></td></tr><tr><td align="left"><code>x &lt;|&lt; y</code></td><td align="left">相当于 <code>x &lt;&lt; y.pipeBackward()</code>，返回 <code>y</code></td></tr><tr><td align="left"><code>x &gt;|&gt; y</code></td><td align="left">相当于 <code>x.pipeBackward() &gt;&gt; y</code>，返回 <code>y</code></td></tr><tr><td align="left"><code>x &lt;+&lt; y</code></td><td align="left">相当于 <code>x &lt;&lt; y.pipeAll()</code>，返回 <code>y</code></td></tr><tr><td align="left"><code>x &gt;+&gt; y</code></td><td align="left">相当于 <code>x.pipeAll() &gt;&gt; y</code>，返回 <code>y</code></td></tr></tbody></table><p>借助 <code>&lt;&lt;</code>、<code>&gt;&gt;</code> 等流操作符，我们可以实现可读性较强的 <code>StreamIO</code> 连接甚至级连，比如：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> s1 = <span class="type">Stream</span>(<span class="type">UInt</span>(<span class="number">8.</span><span class="type">W</span>))</span><br><span class="line">s1 &lt;-&lt; uAnotherModule.io.outStream</span><br><span class="line">s1.haltWhen(somethingEnable) &gt;&gt; uSomeModule.io.inStream</span><br></pre></td></tr></table></figure><h2 id="配套组件"><a href="#配套组件" class="headerlink" title="配套组件"></a>配套组件</h2><p>Chipmunk 包括了一系列 <code>StreamIO</code> 的配套组件。</p><h3 id="StreamFork-StreamJoin"><a href="#StreamFork-StreamJoin" class="headerlink" title="StreamFork&#x2F;StreamJoin"></a>StreamFork&#x2F;StreamJoin</h3><p>StreamFork 可以将一个上游 <code>StreamIO</code> 分叉成多个下游 <code>StreamIO</code>，每个下游 <code>StreamIO</code> 会分别完成仅一次握手，上游 <code>StreamIO</code> 会在所有下游 <code>StreamIO</code> 完成握手后才完成握手。为了提高性能，每个下游 <code>StreamIO</code> 是否握手是独立进行的，当它 <code>ready</code> 有效时即完成握手，而不需要等到所有下游 <code>StreamIO</code> 的 <code>ready</code> 都有效。</p><p>StreamJoin 可以将多个上游 <code>StreamIO</code> 合并成一个下游 <code>StreamIO</code>，当且仅当所有上游 <code>StreamIO</code> 的 <code>valid</code> 都有效时，才会发生握手。</p><p>在 <code>object StreamFork</code>&#x2F;<code>object StreamJoin</code> 中，Chipmunk 提供了多个接口略有差别的方法。用户可以阅读代码中的注释，根据自己的需求选择合适的方法。</p><h3 id="StreamMux-Demux-…"><a href="#StreamMux-Demux-…" class="headerlink" title="StreamMux&#x2F;Demux&#x2F;…"></a>StreamMux&#x2F;Demux&#x2F;…</h3><p>TODO</p><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="https://github.com/zhutmost/chipmunk">Chipmunk Github</a></li></ul><p><a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-size:12px;line-height:1.2;display:inline-block;border-radius:3px" href="https://unsplash.com" target="_blank" rel="noopener noreferrer" title="Unsplash"><span style="display:inline-block;padding:2px 3px"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white" viewBox="0 0 32 32"><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px">photoed by Annegret Kammer</span></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在数字电路设计中，我们经常使用 Ready&amp;#x2F;Valid 握手协议来解耦数据流，Chisel 提供了 &lt;code&gt;DecoupledIO&lt;/code&gt; 用以实现这一协议。然而，&lt;code&gt;DecoupledIO&lt;/code&gt; 仅是一个预置的 &lt;code&gt;Bundle&lt;/code&gt;，缺少与之配套的一系列常用组件（例如寄存器切片、Mux&amp;#x2F;Demux 等），此外它也未能搭配 &lt;code&gt;chipmunk.IsMasterSlave&lt;/code&gt;。&lt;code&gt;chipmunk&lt;/code&gt; 为 &lt;code&gt;DecoupledIO&lt;/code&gt; 提供了一个“威力加强版”的 Ready&amp;#x2F;Valid 握手协议——&lt;code&gt;chipmunk.StreamIO&lt;/code&gt;。&lt;/p&gt;</summary>
    
    
    
    <category term="Engineering" scheme="https://zhutmost.com/categories/Engineering/"/>
    
    
    <category term="Chisel" scheme="https://zhutmost.com/tags/Chisel/"/>
    
    <category term="Chipmunk" scheme="https://zhutmost.com/tags/Chipmunk/"/>
    
  </entry>
  
  <entry>
    <title>🐿️ Chipmunk - Bits/Data 等的更多方法</title>
    <link href="https://zhutmost.com/Engineering/chipmunk-bits-misc/"/>
    <id>https://zhutmost.com/Engineering/chipmunk-bits-misc/</id>
    <published>2023-06-10T13:21:59.059Z</published>
    <updated>2023-08-16T11:31:57.704Z</updated>
    
    <content type="html"><![CDATA[<p><code>chipmunk</code> 为 Chisel 的原生类型 <code>Bits</code>&#x2F;<code>Data</code> 等增加了若干额外的方法（主要是语法糖），为用户提供了一些更加便捷的编码选择，提高代码的可读性。</p><span id="more"></span><h2 id="chisel3-Bits-的额外方法"><a href="#chisel3-Bits-的额外方法" class="headerlink" title="chisel3.Bits 的额外方法"></a><code>chisel3.Bits</code> 的额外方法</h2><p><code>chisel3.Bits</code> 是 Chisel 的 <code>UInt</code>&#x2F;<code>SInt</code>&#x2F;<code>Bool</code> 等类型的父类，因此以下方法可以被这些类型的实例调用。</p><p>这些方法是在 <code>chipmunk.AddMethodsToBits</code> 这个隐式类中实现的。</p><h3 id="msb-lsb-—-获取信号的最高-低-n-比特"><a href="#msb-lsb-—-获取信号的最高-低-n-比特" class="headerlink" title="msb&#x2F;lsb — 获取信号的最高&#x2F;低 n 比特"></a><code>msb</code>&#x2F;<code>lsb</code> — 获取信号的最高&#x2F;低 n 比特</h3><p><code>chisel3.Bits</code> 已提供了类似的方法 <code>x.head(n)</code> 和 <code>x.tail(n)</code>，其中前者是获取该信号的高 n 比特，后者是去掉该信号的高 n 比特（相当于 <code>x.head(x.getWidth - n)</code>）。这两个方法显然是来自函数式编程语言处理队列的习惯（<del>Haskell 用户狂喜</del>），但和绝大多数硬件工程师的习惯很不一致，且导致代码可读性降低。硬件工程师习惯用“某某信号的高N比特&#x2F;低N比特”来对多比特信号进行切片。</p><p>因此，Chipmunk 提供了 <code>x.msb(n)</code> 和 <code>x.lsb(n)</code> 两组方法，它们的功能正如方法名（most&#x2F;least significant bits）：前者 <code>x.msb(n)</code> 和 <code>x.head(n)</code> 行为类似，后者 <code>x.lsb(n)</code> 则是获取该信号的低 n 比特。</p><p>具体如下：</p><ul><li><code>def msb(n: Int = 1): UInt</code><br>返回当前信号实例的最高 n 比特。</li><li><code>def lsb(n: Int = 1): UInt</code><br>返回当前信号实例的最低 n 比特。</li><li><code>def msb: Bool</code><br>返回当前信号实例的最高 1 比特，注意返回类型为 <code>Bool</code>，与 <code>msb()</code> 不同。</li><li><code>def lsb: Bool</code><br>返回当前信号实例的最高 1 比特，注意返回类型为 <code>Bool</code>，与 <code>lsb()</code> 不同。</li></ul><h3 id="setAll-clearAll-setAllTo-—-将信号的所有比特赋-1-或-0"><a href="#setAll-clearAll-setAllTo-—-将信号的所有比特赋-1-或-0" class="headerlink" title="setAll&#x2F;clearAll&#x2F;setAllTo — 将信号的所有比特赋 1 或 0"></a><code>setAll</code>&#x2F;<code>clearAll</code>&#x2F;<code>setAllTo</code> — 将信号的所有比特赋 1 或 0</h3><p>将一个信号的所有比特赋 1 或 0 是一个很普遍的需求，SystemVerilog 中引入了专门的语法：</p><figure class="highlight plaintext"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">assign allOnes = &#x27;1;</span><br><span class="line">assign allZeros = &#x27;0;</span><br></pre></td></tr></table></figure><p>Chisel 中赋全 0 是容易实现的（<code>x := 0.U</code>），但赋全 1 缺乏优雅易读的实现方法。常见的写法包括：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">x1 := <span class="type">Fill</span>(x1.getWidth, b).asTypeOf(x1)</span><br><span class="line">x2 := ~ <span class="number">0.</span><span class="type">U</span> <span class="comment">// ~ 0.S if SInt</span></span><br></pre></td></tr></table></figure><p>无论如何，都很不直观。特别是如果我希望将所有比特赋值为某个 <code>Bool</code> 信号或某个 Scala <code>Boolean</code> 变量输出时，代码会变得更加难以阅读。</p><p>因此，Chipmunk 提供了 <code>setAll</code>&#x2F;<code>clearAll</code>&#x2F;<code>setAllTo</code> 等一系列方法。具体如下：</p><ul><li><code>def setAllTo(b: Bool): T</code><br>将信号的每个比特都赋值为 b，并返回该信号。</li><li><code>def setAllTo(b: Boolean): T</code><br>将信号的每个比特都赋值为 b 的 <code>Bool</code> 字面量（即<code>b.B</code>），并返回该信号。</li><li><code>def setAll(): T</code><br>将信号的每个比特都赋值为 <code>true.B</code>，并返回该信号。</li><li><code>def clearAll(): T</code><br>将信号的每个比特都赋值为 <code>false.B</code>，并返回该信号。</li></ul><h3 id="isOneHot-—-判断当前信号是否为独热码（one-hot）"><a href="#isOneHot-—-判断当前信号是否为独热码（one-hot）" class="headerlink" title="isOneHot — 判断当前信号是否为独热码（one-hot）"></a><code>isOneHot</code> — 判断当前信号是否为独热码（one-hot）</h3><p>如方法名的字面意思，判断当前信号是否为独热码。若是则输出 <code>true.B</code>，反之则输出 <code>false.B</code>。</p><h2 id="chisel3-Data-的额外方法"><a href="#chisel3-Data-的额外方法" class="headerlink" title="chisel3.Data 的额外方法"></a><code>chisel3.Data</code> 的额外方法</h2><p><code>chisel3.Data</code> 是 Chisel 的各硬件类型的父类。</p><p>这些方法是在 <code>chipmunk.AddMethodsToData</code> 这个隐式类中实现的。</p><h3 id="dontTouch-—-dontTouch-的语法糖"><a href="#dontTouch-—-dontTouch-的语法糖" class="headerlink" title="dontTouch — dontTouch() 的语法糖"></a><code>dontTouch</code> — <code>dontTouch()</code> 的语法糖</h3><p><code>chisel3.dontTouch</code> 可以阻止 Chisel 对该信号进行优化，常用于保留某中间信号的命名、保留与模块输出无关的电路等。这是一个单例对象，下面是 Chisel 提供的一个用法等例子：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> b = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  io.b := io.a</span><br><span class="line">  <span class="keyword">val</span> dead = <span class="type">RegNext</span>(io.a +% <span class="number">1.</span><span class="type">U</span>) <span class="comment">// normally dead would be pruned by DCE</span></span><br><span class="line">  dontTouch(dead) <span class="comment">// Marking it as such will preserve it</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Chipmunk 提供了一个方法版本，可以直接调用 Data 类型的 dontTouch 方法实现同样的效果，为用户提供更多的编码选择。因此，上面的代码也可以写成下面这样，在有的时候这可以节省代码量。</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyModule</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> a = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">    <span class="keyword">val</span> b = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">  &#125;)</span><br><span class="line">  io.b := io.a</span><br><span class="line">  <span class="keyword">val</span> dead = <span class="type">RegNext</span>(io.a +% <span class="number">1.</span><span class="type">U</span>).dontTouch</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="https://github.com/zhutmost/chipmunk">Chipmunk Github</a></li></ul><p><a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-size:12px;line-height:1.2;display:inline-block;border-radius:3px" href="https://unsplash.com" target="_blank" rel="noopener noreferrer" title="Unsplash"><span style="display:inline-block;padding:2px 3px"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white" viewBox="0 0 32 32"><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px">photoed by Annegret Kammer</span></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;chipmunk&lt;/code&gt; 为 Chisel 的原生类型 &lt;code&gt;Bits&lt;/code&gt;&amp;#x2F;&lt;code&gt;Data&lt;/code&gt; 等增加了若干额外的方法（主要是语法糖），为用户提供了一些更加便捷的编码选择，提高代码的可读性。&lt;/p&gt;</summary>
    
    
    
    <category term="Engineering" scheme="https://zhutmost.com/categories/Engineering/"/>
    
    
    <category term="Chisel" scheme="https://zhutmost.com/tags/Chisel/"/>
    
    <category term="Chipmunk" scheme="https://zhutmost.com/tags/Chipmunk/"/>
    
  </entry>
  
  <entry>
    <title>🐿️ Chipmunk - 下降沿触发寄存器 RegNeg</title>
    <link href="https://zhutmost.com/Engineering/chipmunk-regneg/"/>
    <id>https://zhutmost.com/Engineering/chipmunk-regneg/</id>
    <published>2023-06-02T15:12:02.048Z</published>
    <updated>2023-08-16T11:31:13.704Z</updated>
    
    <content type="html"><![CDATA[<p><code>chipmunk</code> 提供了在时钟负沿触发的寄存器 <code>RegNegNext</code> 和 <code>RegNegEnable</code>。它们具有和<code>chisel3.RegNext</code>、<code>chisel3.util.RegEnable</code> 类似的接口，唯一的区别是其在时钟的下降沿（而不是上升沿）完成数据锁存。</p><span id="more"></span><h2 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h2><p>Chisel 已经提供了一系列的时钟上升沿触发的寄存器，包括 <code>RegInit</code>、<code>RegNext</code>、<code>RegEnable</code> 等。有些场合下我们需要生成一些时钟下降沿采样的寄存器，但现阶段在 Chisel 中我们只能采用 BlackBox 的方法实现。</p><p>关于 Chisel 是否应该添加对时钟下降沿触发寄存器的原生支持，社区在 FIRRTL 时代就进行过一些讨论（如 <a href="https://github.com/chipsalliance/firrtl/issues/695">#695</a>）。尽管 Chisel 现在的后端 CIRCT Firtool 是支持生成 <code>negedge clock</code> 电路的，但目前 Chisel 前端还没有对应的结构。</p><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p><code>chipmunk</code> 提供了四种不同签名的下降沿触发寄存器：</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">RegNegNext</span>(next: <span class="type">T</span>)</span><br><span class="line"><span class="type">RegNegNext</span>(next: <span class="type">T</span>, init: <span class="type">T</span>, isResetAsync: <span class="type">Boolean</span> = <span class="literal">true</span>)</span><br><span class="line"><span class="type">RegNegEnable</span>(next: <span class="type">T</span>, enable: <span class="type">Bool</span>)</span><br><span class="line"><span class="type">RegNegEnable</span>(next: <span class="type">T</span>, init: <span class="type">T</span>, enable: <span class="type">Bool</span>, isResetAsync: <span class="type">Boolean</span> = <span class="literal">true</span>)</span><br></pre></td></tr></table></figure><p>它们的参数功能如下：</p><ul><li><code>next</code>：待锁存的输入数据，会在时钟的下降沿被采样。</li><li><code>init</code>：复位初始数据；需要上下文中存在复位信号。</li><li><code>enable</code>：锁存使能信号，当它为<code>true.B</code>时<code>next</code>会被锁存。</li><li><code>isResetAsync</code>：复位信号是否为异步复位（<code>AsyncReset</code>）；默认为<code>true</code>。</li></ul><p>用户不需要在参数列表中给定时钟和复位信号，和 Chisel 的 <code>RegXXX</code> 一样，它们会根据上下文使用对应的时钟和复位信号。</p><p>唯一需要注意的是参数<code>isResetAsync</code>。由于 Chisel 的类型系统限制，同步复位和异步复位的类型都是<code>ResetType</code>（除非显式声明为<code>AsyncReset()</code>，但这种情况不常见），Chisel 会在 Elaboration 阶段再推导决定它们属于哪种类型的复位信号并赋予对应的类型：<code>Bool</code> 或 <code>AsyncReset</code>。Chisel 没有提供公开 API 判断复位类型，因此需要用户通过设置 <code>isResetAsync</code> 告诉 <code>RegNeg</code> 最终使用哪种复位。</p><!-- 如果用户的设置与实际 Chisel 推导出的复位类型不符，后端代码生成阶段 Firtool 会报错。 --><p>下面给出一些实际用例供参考。</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">val</span> nextVal0 = <span class="type">Wire</span>(<span class="type">Vec</span>(<span class="number">8</span>, <span class="type">UInt</span>(<span class="number">3.</span><span class="type">W</span>)))</span><br><span class="line"><span class="keyword">val</span> nextVal1 = <span class="type">Wire</span>(<span class="type">SInt</span>(<span class="number">3.</span><span class="type">W</span>))</span><br><span class="line"><span class="keyword">val</span> enable1 = <span class="type">Wire</span>(<span class="type">Bool</span>())</span><br><span class="line"></span><br><span class="line">withClockAndReset(clock, reset) &#123;</span><br><span class="line">  <span class="keyword">val</span> r0 = <span class="type">RegNegNext</span>(io.nextVal0, init = <span class="type">VecInit</span>(<span class="type">Seq</span>.fill(<span class="number">8</span>)(<span class="number">1.</span><span class="type">U</span>(<span class="number">3.</span><span class="type">W</span>))))</span><br><span class="line">  <span class="keyword">val</span> r1 = <span class="type">RegNegEnable</span>(io.nextVal1, <span class="number">-3.</span><span class="type">S</span>, io.enable1)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="https://github.com/zhutmost/chipmunk">Chipmunk Github</a></li></ul><p><a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-size:12px;line-height:1.2;display:inline-block;border-radius:3px" href="https://unsplash.com" target="_blank" rel="noopener noreferrer" title="Unsplash"><span style="display:inline-block;padding:2px 3px"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white" viewBox="0 0 32 32"><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px">photoed by Annegret Kammer</span></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;chipmunk&lt;/code&gt; 提供了在时钟负沿触发的寄存器 &lt;code&gt;RegNegNext&lt;/code&gt; 和 &lt;code&gt;RegNegEnable&lt;/code&gt;。它们具有和&lt;code&gt;chisel3.RegNext&lt;/code&gt;、&lt;code&gt;chisel3.util.RegEnable&lt;/code&gt; 类似的接口，唯一的区别是其在时钟的下降沿（而不是上升沿）完成数据锁存。&lt;/p&gt;</summary>
    
    
    
    <category term="Engineering" scheme="https://zhutmost.com/categories/Engineering/"/>
    
    
    <category term="Chisel" scheme="https://zhutmost.com/tags/Chisel/"/>
    
    <category term="Chipmunk" scheme="https://zhutmost.com/tags/Chipmunk/"/>
    
  </entry>
  
  <entry>
    <title>🐿️ Chipmunk - 用 Master/Slave 定义 Bundle 方向</title>
    <link href="https://zhutmost.com/Engineering/chipmunk-master-slave/"/>
    <id>https://zhutmost.com/Engineering/chipmunk-master-slave/</id>
    <published>2023-04-20T16:28:02.000Z</published>
    <updated>2023-08-16T11:32:12.001Z</updated>
    
    <content type="html"><![CDATA[<p><code>chipmunk.IsMasterSlave</code> 使用户在定义 <code>Bundle</code> 时可同时规定其属于数据的生产者（Master）或消费者（Slave）。当以 <code>Master()</code> 定义的 <code>Bundle</code> 被以 <code>Slave()</code> 形式例化时，内部信号的方向会自动翻转，反之亦然。</p><span id="more"></span><h2 id="Why？"><a href="#Why？" class="headerlink" title="Why？"></a>Why？</h2><p><code>chisel3.Bundle</code> 在例化时，可以使用 <code>Flipped()</code> 翻转其内部信号的方向。在许多Chisel项目中，我们约定 <code>Bundle</code> 作为模块端口时默认是生产者，如果我们希望它作为消费者，则显式地用 <code>Flipped()</code> 把它包裹起来。然而，很多用户并不总是遵守这一约定，所以用户经常搞不清楚端口需不需要用 <code>Flipped()</code> 包裹起来。实践中，对于别人代码中的模块接口，通常需要阅读其代码和文档才能判断这些 <code>Bundle</code> 属于 Master 还是 Slave（是否需要翻转其方向）。</p><p>例如，如下代码片段中的 SRAM 读写接口 <code>SramReadWriteIO</code> 看起来非常合理，但根据上述约定，这一接口既然属于Slave，其内部信号方向应该反过来定义（比如 <code>enable</code> 应当是 <code>Output()</code>）。不遵守约定的结果，就是其他用户在调用这一 <code>Bundle</code> 的的时候经常会陷入困惑：我应不应该套上 <code>Flipped()</code>？</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SramReadWriteIO</span> <span class="keyword">extends</span> <span class="title">Bundle</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> enable  = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">  <span class="keyword">val</span> read    = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">  <span class="keyword">val</span> addr    = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">  <span class="keyword">val</span> dataIn  = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">  <span class="keyword">val</span> dataOut = <span class="type">Output</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Usage"><a href="#Usage" class="headerlink" title="Usage"></a>Usage</h2><p><code>chipmunk.IsMasterSlave</code> 是一个特质，用户在定义 <code>Bundle</code> 时可以选择混入这一特质。它要求额外定义一方法 <code>def isMaster: Boolean</code>，<code>true</code> 表示该 <code>Bundle</code> 当前的信号方向属于 Master，反之属于 Slave。</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">SramWriteIO</span> <span class="keyword">extends</span> <span class="title">Bundle</span> <span class="keyword">with</span> <span class="title">IsMasterSlave</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> enable  = <span class="type">Input</span>(<span class="type">Bool</span>())</span><br><span class="line">  <span class="keyword">val</span> addr    = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">16.</span><span class="type">W</span>))</span><br><span class="line">  <span class="keyword">val</span> dataIn  = <span class="type">Input</span>(<span class="type">UInt</span>(<span class="number">32.</span><span class="type">W</span>))</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isMaster</span> </span>= <span class="literal">false</span> <span class="comment">// This is a Slave Bundle</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如此一来，在例化它时，用户可以用 <code>Master()</code> 或 <code>Slave()</code> 来选择它内部信号的方向。对于一个套上 <code>Slave()</code> 的 Master <code>Bundle</code>，其内部信号方向会相应取反。用户不需要关心何时需要 <code>Flipped</code>，只需要记住这一 <code>Bundle</code> 在当前模块的数据传输关系。</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Sram</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> rw = <span class="type">Slave</span>(<span class="keyword">new</span> <span class="type">SramReadWriteIO</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>此外，<code>Master</code>&#x2F;<code>Slave</code> 还支持嵌套使用，从而允许用户构造出如下 AMBA AXI 总线这样的复杂例子。</p><figure class="highlight scala"><figcaption><span>Code Snippet</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AxiIO</span> <span class="keyword">extends</span> <span class="title">Bundle</span> <span class="keyword">with</span> <span class="title">IsMasterSlave</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> aw = <span class="type">Master</span>(<span class="keyword">new</span> <span class="type">AxiWriteAddrChannelIO</span>)</span><br><span class="line">  <span class="keyword">val</span> ar = <span class="type">Master</span>(<span class="keyword">new</span> <span class="type">AxiReadAddrChannelIO</span>)</span><br><span class="line">  <span class="keyword">val</span> r = <span class="type">Slave</span>(<span class="keyword">new</span> <span class="type">AxiReadDataChannelIO</span>)</span><br><span class="line">  <span class="keyword">val</span> w = <span class="type">Master</span>(<span class="keyword">new</span> <span class="type">AxiWriteDataChannelIO</span>)</span><br><span class="line">  <span class="keyword">val</span> b = <span class="type">Slave</span>(<span class="keyword">new</span> <span class="type">AxiWriteRespChannelIO</span>)</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">isMaster</span> </span>= <span class="literal">true</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AxiSlave</span> <span class="keyword">extends</span> <span class="title">Module</span> </span>&#123;</span><br><span class="line">  <span class="keyword">val</span> io = <span class="type">IO</span>(<span class="keyword">new</span> <span class="type">Bundle</span> &#123;</span><br><span class="line">    <span class="keyword">val</span> axi = <span class="type">Slave</span>(<span class="keyword">new</span> <span class="type">AxiIO</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="See-Also"><a href="#See-Also" class="headerlink" title="See Also"></a>See Also</h2><ul><li><a href="https://github.com/zhutmost/chipmunk">Chipmunk Github</a></li></ul><p><a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-size:12px;line-height:1.2;display:inline-block;border-radius:3px" href="https://unsplash.com" target="_blank" rel="noopener noreferrer" title="Unsplash"><span style="display:inline-block;padding:2px 3px"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white" viewBox="0 0 32 32"><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px">photoed by Annegret Kammer</span></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;code&gt;chipmunk.IsMasterSlave&lt;/code&gt; 使用户在定义 &lt;code&gt;Bundle&lt;/code&gt; 时可同时规定其属于数据的生产者（Master）或消费者（Slave）。当以 &lt;code&gt;Master()&lt;/code&gt; 定义的 &lt;code&gt;Bundle&lt;/code&gt; 被以 &lt;code&gt;Slave()&lt;/code&gt; 形式例化时，内部信号的方向会自动翻转，反之亦然。&lt;/p&gt;</summary>
    
    
    
    <category term="Engineering" scheme="https://zhutmost.com/categories/Engineering/"/>
    
    
    <category term="Chisel" scheme="https://zhutmost.com/tags/Chisel/"/>
    
    <category term="Chipmunk" scheme="https://zhutmost.com/tags/Chipmunk/"/>
    
  </entry>
  
  <entry>
    <title>2023年智能芯片领域会议概览</title>
    <link href="https://zhutmost.com/Research/asic-conf-ddl-2023/"/>
    <id>https://zhutmost.com/Research/asic-conf-ddl-2023/</id>
    <published>2022-11-13T06:31:19.000Z</published>
    <updated>2023-08-14T12:21:48.062Z</updated>
    
    <content type="html"><![CDATA[<p>为了准确把握每一个学术交流（摸鱼）的机会，本文收集了智能芯片领域（固态电路、体系结构等）的相关学术会议的投稿信息，包括召开时间、地点、截稿时间等。<del>之后，我将尽量保持本文持续更新。</del></p><span id="more"></span><p>由于多数会议的投稿截稿时间都会延期一至两周，因此下表中的截稿时间通常只是个大约时间。</p><h2 id="固态电路"><a href="#固态电路" class="headerlink" title="固态电路"></a>固态电路</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">ISSCC’23</td><td>San Francisco, CA, US</td><td>2023.02.19</td><td>2022.09.07</td><td><a href="https://www.isscc.org/">Link</a></td></tr><tr><td align="center">VLSI’23</td><td>Kyoto, Japan</td><td>2023.06.11</td><td>2023.02.01</td><td><a href="https://www.vlsisymposium.org/">Link</a></td></tr><tr><td align="center">ESSCIRC’23</td><td>Lisbon, Portugal</td><td>2023.09.11</td><td>2023.04.14</td><td><a href="https://www.esscirc-essderc2023.org/">Link</a></td></tr><tr><td align="center">ASSCC’23</td><td>Haikou, China</td><td>2023.11.05</td><td>2023.06.05</td><td><a href="https://www.a-sscc2023.com/">Link</a></td></tr><tr><td align="center">CICC’23</td><td>San Antonio, TX, US</td><td>2023.04.23</td><td>2022.11.14</td><td><a href="https://www.ieee-cicc.org/">Link</a></td></tr><tr><td align="center">HOTCHIPS’23</td><td>San Francisco, CA, US</td><td>2023.08.27</td><td>2023.03.22</td><td><a href="https://hotchips.org/">Link</a></td></tr></tbody></table><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">ISCA’23</td><td>Orlando, FL, USA</td><td>2023.06.17</td><td>2022.11.14</td><td><a href="https://iscaconf.org/isca2023/">Link</a></td></tr><tr><td align="center">MICRO’23</td><td>Toronto, Canada</td><td>2023.10.28</td><td>2023.04.21</td><td><a href="https://microarch.org/micro56">Link</a></td></tr><tr><td align="center">HPCA’23</td><td>Montreal, Canada</td><td>2023.02.25</td><td>2022.08.01</td><td><a href="https://hpca-conf.org/2023">Link</a></td></tr><tr><td align="center">DAC’23</td><td>San Francisco, CA, US</td><td>2023.07.09</td><td>2022.11.14</td><td><a href="https://www.dac.com/">Link</a></td></tr></tbody></table><h2 id="机器视觉"><a href="#机器视觉" class="headerlink" title="机器视觉"></a>机器视觉</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">CVPR’23</td><td>Vancouver, Canada</td><td>2023.06.18</td><td>2022.11.04</td><td><a href="https://cvpr2023.thecvf.com/">Link</a></td></tr><tr><td align="center">IROS’23</td><td>Detroit, MI, US</td><td>2023.10.01</td><td>2023.03.01</td><td><a href="https://ieee-iros.org/">Link</a></td></tr><tr><td align="center">ICRA’23</td><td>London, UK</td><td>2023.05.29</td><td>2022.08.05</td><td><a href="https://www.icra2023.org/">Link</a></td></tr></tbody></table><h2 id="其他会议"><a href="#其他会议" class="headerlink" title="其他会议"></a>其他会议</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">ISCAS’23</td><td>Monterey, CA, US</td><td>2023.05.21</td><td>2022.11.07</td><td><a href="https://iscas2023.org/">Link</a></td></tr><tr><td align="center">AICAS’23</td><td>Hangzhou, China</td><td>2023.06.11</td><td>2023.02.03</td><td><a href="http://www.aicas2023.org/">Link</a></td></tr><tr><td align="center">APCCAS’23</td><td>Hyderabad, India</td><td>2023.11.20</td><td>2023.06.04</td><td><a href="https://www.apccas2023.org/">Link</a></td></tr><tr><td align="center">MWSCAS’23</td><td>Phoenix, AZ, US</td><td>2023.04.07</td><td>2022.08.06</td><td><a href="https://www.mwscas2023.org/">Link</a></td></tr><tr><td align="center">BioCAS’23</td><td>Toronta, Canada</td><td>2023.10.19</td><td>2023.06.09</td><td><a href="https://2023.ieee-biocas.org/">Link</a></td></tr><tr><td align="center">GLSVLSI’23</td><td>Knoxville, TN, US</td><td>2023.06.05</td><td>2023.02.06</td><td><a href="https://www.glsvlsi.org/">Link</a></td></tr><tr><td align="center">ICCAD’23</td><td>San Francisco, CA, US</td><td>2023.10.29</td><td>2023.05.15</td><td><a href="https://iccad.com/">Link</a></td></tr><tr><td align="center">ASP-DAC’23</td><td>Tokyo, Japan</td><td>2023.01.16</td><td>2022.07.24</td><td><a href="https://www.aspdac.com/aspdac2023">Link</a></td></tr><tr><td align="center">DATE’23</td><td>Antwerp, Belgium</td><td>2023.04.17</td><td>2022.09.18</td><td><a href="https://www.date-conference.com/">Link</a></td></tr><tr><td align="center">MLSys’23</td><td>Southern FL, US</td><td>2023.06.04</td><td>2022.10.28</td><td><a href="https://mlsys.org/">Link</a></td></tr><tr><td align="center">FPGA’23</td><td>Monterey, CA, US</td><td>2023.02.12</td><td>2022.09.23</td><td><a href="https://www.isfpga.org/">Link</a></td></tr><tr><td align="center">FPT’23</td><td>Yokohama, Japan</td><td>2023.12.11</td><td>2023.07.14</td><td><a href="https://fpt2023.org/">Link</a></td></tr><tr><td align="center">FPL’23</td><td>Gothenburg, Sweden</td><td>2023.09.04</td><td>2023.03.13</td><td><a href="https://2023.fpl.org/">Link</a></td></tr></tbody></table><p>祝大家投稿顺利～</p><p><a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-size:12px;line-height:1.2;display:inline-block;border-radius:3px" href="https://unsplash.com/photos/SAQl58G-RYs" target="_blank" rel="noopener noreferrer" title="Harvest Fields in Westerham, Kent, 1880-1910 by Helen Allingham"><span style="display:inline-block;padding:2px 3px"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white" viewBox="0 0 32 32"><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px">photoed by Birmingham Museums</span></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了准确把握每一个学术交流（摸鱼）的机会，本文收集了智能芯片领域（固态电路、体系结构等）的相关学术会议的投稿信息，包括召开时间、地点、截稿时间等。&lt;del&gt;之后，我将尽量保持本文持续更新。&lt;/del&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Research" scheme="https://zhutmost.com/categories/Research/"/>
    
    
    <category term="Paper Lives Matter" scheme="https://zhutmost.com/tags/Paper-Lives-Matter/"/>
    
    <category term="AI Chip" scheme="https://zhutmost.com/tags/AI-Chip/"/>
    
  </entry>
  
  <entry>
    <title>SSH 通过 443 端口连接 GitHub</title>
    <link href="https://zhutmost.com/Engineering/github-ssh-443/"/>
    <id>https://zhutmost.com/Engineering/github-ssh-443/</id>
    <published>2022-07-30T04:00:00.000Z</published>
    <updated>2023-08-16T08:08:41.160Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub 提供了两种协议供用户使用 Git 连接—— SSH 和 HTTPS。理论上我可以随意选择两者之一连接到我在 GitHub 上的代码仓库，无论是将云端的仓库 <code>clone</code> 到本地，还是将本地的修改 <code>push</code> 到云端。然而，出于一些奇奇怪怪的原因，我所在的办公网络环境禁止了 22 端口，而 22 端口正是 GitHub 提供 SSH 访问的端口号。尽管可以换用 HTTPS 协议，但无论如何将我电脑上的所有代码仓库的上游都从 <code>git@github.com:...</code> 修改称 <code>https://github.com/...</code> 仍然是一个繁重的体力活。</p><p>为了一劳永逸地解决这个问题，最理想的解决方式是让 Git 的 SSH 协议改用 22 以外的其他端口连接 GitHub。</p><span id="more"></span><h2 id="SSH-连接失败"><a href="#SSH-连接失败" class="headerlink" title="SSH 连接失败"></a>SSH 连接失败</h2><p>我们在 <code>clone</code> GitHub 上的代码仓库时，可以看到 GitHub 提供了两种不同的链接（以我的 SpinalHDL 模版仓库为例）：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zhutmost/spinalhdl-template.git <span class="comment"># HTTPS</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:zhutmost/spinalhdl-template.git <span class="comment"># SSH</span></span><br></pre></td></tr></table></figure><p>其中第一种方式，即 HTTPS 协议，一般总能可以工作（只要能在浏览器里打开 GitHub），而后者依赖 SSH 的正常工作。因为我的网络环境阻断了 22 端口的连接，所以我测试 GitHub 的 SSH 连接时会出现以下报错：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh -T git@github.com</span><br><span class="line">kex_exchange_identification: Connection closed by remote host</span><br><span class="line">Connection closed by xx.xx.xx.xx port 22</span><br></pre></td></tr></table></figure><p>而在理想情况下，上述命令应当输出：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh -T git@github.com</span><br><span class="line">Hi zhutmost! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><h2 id="奇妙的冒名顶替"><a href="#奇妙的冒名顶替" class="headerlink" title="奇妙的冒名顶替"></a>奇妙的冒名顶替</h2><p>仔细发掘<a href="https://docs.github.com/en/authentication/troubleshooting-ssh/using-ssh-over-the-https-port">GitHub的文档</a>，可以发现 GitHub 在另一个域名（ssh.github.com）上提供了一个 443 端口的 SSH 服务。显然，防火墙一般不会阻拦 443 端口（只要能浏览 GitHub 网站就能连上），可以用下面的命令进行测试：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p>为了让Git也能通过上述端口用 SSH 访问 GitHub，我们为上述 SSH 连接方式设置一个别名。首先找到SSH的配置文件，它的路径一般是<code>~/.ssh/config</code>，如果这个文件不存在的话也可以创建一个。然后，在其中增加以下内容：</p><figure class="highlight text"><figcaption><span>ssh_config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  HostName ssh.github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure><p>其中，<code>Host</code> 是别名，<code>HostName</code> 是实际的域名地址，<code>Port</code> 是端口号。因为我希望当我在用 SSH 连接 github.com 时，实际访问的是 ssh.github.com，所以 <code>Host</code> 和 <code>HostName</code> 分别设置成这两个域名（注意不要颠倒顺序）。</p><p>如此一来，ssh.github.com 就成为了 github.com 的“冒名顶替”者。当 Git 通过 SSH 协议试图访问 github.com 的时候，SSH 会发现它是 ssh.github.com 的别名，因此会用 443 端口实际连接到后者。这样，就绕开了本地网路环境对 22 端口的限制。</p><p>（我之所以使用上述方法，是因为我的网络情况比较复杂。建议公司的朋友在使用暗渡陈仓之策前，先和 IT 部门确认下是否合规。）</p><p><a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-size:12px;line-height:1.2;display:inline-block;border-radius:3px" href="https://besthqwallpapers.com/computers/github-wooden-logo-4k-wooden-backgrounds-social-networks-github-logo-178436" target="_blank" rel="noopener noreferrer" title="Wooden Github"><span style="display:inline-block;padding:2px 3px"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white" viewBox="0 0 32 32"><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px">Thumbnail by Besthqwallpapers</span></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GitHub 提供了两种协议供用户使用 Git 连接—— SSH 和 HTTPS。理论上我可以随意选择两者之一连接到我在 GitHub 上的代码仓库，无论是将云端的仓库 &lt;code&gt;clone&lt;/code&gt; 到本地，还是将本地的修改 &lt;code&gt;push&lt;/code&gt; 到云端。然而，出于一些奇奇怪怪的原因，我所在的办公网络环境禁止了 22 端口，而 22 端口正是 GitHub 提供 SSH 访问的端口号。尽管可以换用 HTTPS 协议，但无论如何将我电脑上的所有代码仓库的上游都从 &lt;code&gt;git@github.com:...&lt;/code&gt; 修改称 &lt;code&gt;https://github.com/...&lt;/code&gt; 仍然是一个繁重的体力活。&lt;/p&gt;
&lt;p&gt;为了一劳永逸地解决这个问题，最理想的解决方式是让 Git 的 SSH 协议改用 22 以外的其他端口连接 GitHub。&lt;/p&gt;</summary>
    
    
    
    <category term="Engineering" scheme="https://zhutmost.com/categories/Engineering/"/>
    
    
    <category term="GitHub" scheme="https://zhutmost.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>EdgeBoard的PYNQ移植</title>
    <link href="https://zhutmost.com/Engineering/pynq-compile/"/>
    <id>https://zhutmost.com/Engineering/pynq-compile/</id>
    <published>2021-08-12T14:43:32.000Z</published>
    <updated>2023-08-16T08:44:33.837Z</updated>
    
    <content type="html"><![CDATA[<p>PYNQ是我很喜欢的一个FPGA开源工具。它将Zynq上的各种硬件资源用Python封装了起来，允许用户通过Jupytor Notebook远程调试FPGA。将PYNQ移植到Baidu EdgeBoard上是我去年在COVID疫情期间开的坑（具体请参看<a href="https://github.com/zhutmost/edgeboard">我的GitHub</a>），但中间遇到的小问题有点多，便一直没有完全填上。我最近抽出了些时间重新拾起了这个事情，就顺便把整个过程和遇到的问题都记录下来，以飨后来者。</p><p>相关源代码已开源至<a href="https://github.com/zhutmost/edgeboard">Github</a>，预编译PYNQ镜像文件我也已上传至<a href="https://www.aliyundrive.com/s/6biJpMiKrpD">阿里云盘</a>。因为设备有限，我没有为这个镜像进行所有外设的上板测试。如果你发现了任何问题，欢迎和我联系。</p><span id="more"></span><p>PYNQ官方提供了<a href="https://pynq.readthedocs.io/en/latest/pynq_sd_card.html">SD卡镜像编译的文档</a>，因此一些比较明确的步骤我可能不会详述，请搭配官方文档阅读。</p><p>为了避免混淆，这里先澄清一下很多朋友的一个小误解：本文中的PYNQ指的是PYNQ框架（本质上是一个Ubuntu），而非那两个粉色的开发板（PYNQ-Z1和PYNQ-Z2）。PYNQ可以部署在PYNQ-Z1和PYNQ-Z2上，也可以部署在其他Zynq系列的FPGA上。</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>Xilinx提供了PYNQ-Z1、PYNQ-Z2、ZCU104等开发板的镜像，可以直接从PYNQ网站上下载到，具体列表可以在<a href="http://pynq.io/board.html">PYNQ的下载页面</a>找到（也包括Ultra96等第三方开发板）。如果我们想要在此外的开发板（比如本文中的EdgeBoard Lite）上使用PYNQ，就需要自己编译PYNQ镜像。</p><p>本文的编译目标是PYNQ v2.7。本文写作时（2021年8月）PYNQ2.7的开发已经完成，但是还没有合入主线分支，文档也没有更新（但差别不大，反正各种奇奇怪怪的bug本来也不会写在文档里）。每次大版本（即2.X）更新后，随着时间推移，依赖软件包之间会出现五花八门的兼容性问题，这些问题很可能要到下一次PYNQ大版本更新才会一次性修复。这个问题主要得归咎于Xilinx官方，PYNQ的编译中依赖的很多软件都不指定特定版本。因此，如果你看到本文时已是很久之后，文章中遇到的问题和你遇到的可能不尽相同。</p><p>硬件上，除了Edgeboard本身，我准备了一台半淘汰的笔记本搭建编译环境。这个不是很重要（虚拟机也不是不可以），唯一需要确认的是剩余磁盘空间要够大（大约200GB）。</p><p>PYNQ v2.7需要Vivado&#x2F;Vitis&#x2F;PetaLinux的版本为2020.2。我的操作系统是Ubuntu 18.04.5 LTS。Vivado&#x2F;Vitis 2020.2最高支持Ubuntu 18.04.4，安装时需要修改<code>/etc/os-release</code>骗过安装程序。这里操作系统的版本建议请严格按照Xilinx的安装指南，我不建议你和我一样操作。</p><p>编译过程中需要从互联网上下载大量依赖组件，请确保你能够自由访问互联网。</p><h2 id="理想的编译过程"><a href="#理想的编译过程" class="headerlink" title="理想的编译过程"></a>理想的编译过程</h2><h3 id="设置PYNQ环境"><a href="#设置PYNQ环境" class="headerlink" title="设置PYNQ环境"></a>设置PYNQ环境</h3><p>首先将PYNQ的GitHub Repo复制到本地，并切换到<code>image_v2.7</code>分支。</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ git <span class="built_in">clone</span> https://github.com/Xilinx/PYNQ.git pynq</span><br><span class="line">❯ <span class="built_in">cd</span> pynq</span><br><span class="line">❯ git checkout image_v2.7</span><br></pre></td></tr></table></figure><p>我们接下来的主要工作都在<code>sdbuild</code>目录下进行。先运行<code>scripts/setup_host.sh</code>，它会用apt安装各种需要的包，以及下载QEMU和CrossTool-NG。</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">source</span> ./scripts/setup_host.sh</span><br></pre></td></tr></table></figure><p>这个脚本运行需要很久的时间（主要是因为下载QEMU和CrossTool-NG的安装包），但好在只需要运行一次。</p><p>后续编译过程还会依赖Ninja，然而该脚本中没有安装，因此我们手动安装下。</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ninja-build</span><br></pre></td></tr></table></figure><p>到这里，Xilinx全家桶需要的各种依赖包也安装完成了，接下来就可以安装Xilinx全家桶了。</p><h3 id="安装Xilinx全家桶"><a href="#安装Xilinx全家桶" class="headerlink" title="安装Xilinx全家桶"></a>安装Xilinx全家桶</h3><p>我们需要安装Vivado、Vitis、PetaLinux三个软件。按照PYNQ v2.7的版本要求，三者的版本都必须是2020.2。这里需要注意的是，不要使用管理员权限安装。</p><p>Vivado和Vitis是通过同一个安装程序安装的，安装时命令行运行<code>./xsetup</code>，勾选需要的组件即可。</p><p>PetaLinux安装的命令如下：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ petalinux-v2020.2-final-installer.run --<span class="built_in">dir</span> &lt;xilinx_install_dir&gt;/petalinux/2020.2 --platform <span class="string">&quot;aarch64 arm&quot;</span></span><br></pre></td></tr></table></figure><p>具体安装选项可以参考<a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1144-petalinux-tools-reference-guide.pdf">UG1144</a>。这里存在一个坑，PetaLinux的安装程序允许用户任意指定安装位置，但是PYNQ之前的版本默认却要求它的路径必须是<code>.../2020.2/</code>的形式（v2.7有无修复不确定，我没有去测试）。</p><p>安装完成后，我们需要将下面几行代码加入<code>.bashrc</code>（也可以每次打开命令行手动执行）。这样一来，就可以在命令行中运行这些软件了。</p><figure class="highlight bash"><figcaption><span>.bashrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> &lt;xilinx_install_dir&gt;/petalinux/2020.2/settings.sh</span><br><span class="line"><span class="built_in">source</span> &lt;xilinx_install_dir&gt;/Vivado/2020.2/settings64.sh</span><br><span class="line"><span class="built_in">source</span> &lt;xilinx_install_dir&gt;/Vitis/2020.2/settings64.sh</span><br></pre></td></tr></table></figure><h3 id="添加自定义开发板"><a href="#添加自定义开发板" class="headerlink" title="添加自定义开发板"></a>添加自定义开发板</h3><p>PYNQ在<code>boards</code>文件夹下预置了<code>Pynq-Z1</code>、<code>Pynq-Z2</code>、<code>ZCU104</code>三个与对应开发板同名的文件夹。它们的内部结构大同小异，主要分成以下五个部分：</p><ol><li><code>notebooks</code>；</li><li><code>petalinux_bsp</code>；</li><li><code>packages</code>；</li><li><code>base</code>、<code>logictools</code>等<code>Overlay</code>文件夹；</li><li><code>&lt;board_name&gt;.spec</code>。</li></ol><p>下面简单介绍下这些文件和文件夹的功能，具体的细节（如果你需要定制一些复杂的东西）还请自行阅读PYNQ的编译脚本源代码。</p><p><code>notebooks</code>文件夹会原样复制到最终的用户目录下，每次大家打开Jupyter Notebook后看到的就是它。这个文件夹里的内容不是很重要，一般都是放些教程。</p><p><code>petalinux_bsp</code>文件夹用于PetaLinux生成BSP，它只在<code>sdbuild/scripts/create_bsp.sh</code>脚本中用到。该文件夹里边包括两个文件夹<code>meta-user</code>、<code>hardware_project</code>。其中，<code>meta-user</code>文件夹会被复制到PetaLinux项目文件夹下的<code>project-spec/meta-user</code>，里面放设备树文件、各种用户配置等（如果你对PetaLinux项目的目录结构不了解的话可以参考<a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1144-petalinux-tools-reference-guide.pdf">UG1144</a>）。<code>hardware_project</code>里需要放<code>.xsa</code>硬件描述文件（该文件由Vivado导出），或者也可以放一些脚本（至少包括一个Makefile）供PetaLinux实时地生成<code>.xsa</code>文件。如果用户在<code>&lt;board_name&gt;.spec</code>中指定了BSP，那么<code>hardware_project</code>不会被用到。这里一个文档中一个没有注明的是，<code>meta-user</code>总是会起作用，即使你指定了BSP，它也会覆盖掉里边的<code>meta-user</code>并重新打包。</p><p><code>packages</code>文件夹的结构和<code>sdbuild/packages</code>的结构类似，这两个目录下的每个文件夹对应一个个的组件，在编译过程中会被安装到RootFS中。安装过程主要是在<code>sdbuild/scripts/install_packages.sh</code>中进行。如果你需要增加组件，建议阅读此脚本和<code>sdbuild/packages/README.md</code>了解更多细节。</p><p>其他文件夹中如果存在Makefile文件，就会被认为是<code>Overlay</code>文件夹。在编译<code>pynq</code>本身时，<code>&lt;pynq_repo_dir&gt;/build.sh</code>脚本会试图进入这些文件夹，并挨个检查是否存在<code>.bit</code>、<code>.hwh</code>、<code>.xsa</code>等文件。这些文件夹不是必须的，主要是为用户提供一些针对该开发板的预置<code>Overlay</code>。</p><p><code>&lt;board_name&gt;.spec</code>文件描述了针对该开发板的各种配置和文件路径。它的格式如下所示：</p><figure class="highlight makefile"><figcaption><span>board_name.spec</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ARCH_&lt;board_name&gt; := aarch64 <span class="comment"># Zynq的CPU架构，可以是aarch64或arm</span></span><br><span class="line">BSP_&lt;board_name&gt; := ... <span class="comment"># 开发板的BSP文件（如果有的话）</span></span><br><span class="line">BITSTREAM_&lt;board_name&gt; := ... <span class="comment"># 默认的比特流文件</span></span><br><span class="line">FPGA_MANAGER_&lt;board_name&gt; := 1</span><br><span class="line"></span><br><span class="line">STAGE4_PACKAGES_&lt;board_name&gt; := pynq ethernet ...</span><br></pre></td></tr></table></figure><p>注意这里的<code>board_name</code>要和文件夹的名字一致。</p><p>接下来我们可以依样画葫芦为自己的开发板配置这些文件了。<br>我在<a href="https://github.com/zhutmost/edgeboard/tree/master/pynq">edgeboard的仓库</a>中放置了针对EdgeBoard Lite的配置文件，如果需要的话你也可以参考。</p><h3 id="一把梭编译，赌人品"><a href="#一把梭编译，赌人品" class="headerlink" title="一把梭编译，赌人品"></a>一把梭编译，赌人品</h3><p>按照官方的流程，理论上我们可以开始进行漫长的编译了。不过我强烈建议你先阅读下后续的几个章节再开始编译（可以避免很多无谓的时间浪费）。</p><p>在<code>sdbuild</code>下运行：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ make BOARDDIR=&lt;edgeboard_repo_dir&gt;/edgeboard/pynq BOARDS=edgeboard-fz3a</span><br></pre></td></tr></table></figure><p>运气不错的话，我们能够在几个小时后获得最终的SD卡镜像<code>edgeboard-fz3a-2.7.0.img</code>，然后就可以将其烧写到SD卡上了。</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo <span class="built_in">dd</span> <span class="keyword">if</span>=&lt;pynq_repo_dir&gt;/sdbuild/output/edgeboard-fz3a-2.7.0.img bs=1M of=/dev/mmcblk0 &amp;&amp; <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p>注意这里你的SD卡设备名可能不是<code>/dev/mmcblk0</code>，请务必再三确认，以免写入其他磁盘丢失数据。</p><h2 id="各种常见和不常见的Bug"><a href="#各种常见和不常见的Bug" class="headerlink" title="各种常见和不常见的Bug"></a>各种常见和不常见的Bug</h2><p>实践中，上一步十之八九会遇到各种奇奇怪怪的问题，然后报错退出。这里我没法给出一个万能方法，只能说“具体情况，具体分析”。记得多翻日志，多问谷歌。</p><p>我把各种我遇到的问题罗列于此，并提供了我的原因分析和解决方法。</p><h3 id="NodeJS安装时报错base-files-is-not-configured"><a href="#NodeJS安装时报错base-files-is-not-configured" class="headerlink" title="NodeJS安装时报错base_files is not configured"></a>NodeJS安装时报错<code>base_files is not configured</code></h3><p>在运行到<code>sdbuild/packages/jupyter/qemu.sh</code>时，它会用apt安装NodeJS（这是运行Jupyter Notebook必要的）。此时，apt安装无法完成，并出现以下报错：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Setting up base-files (11ubuntu5) ...</span><br><span class="line">/bin/rmdir: failed to remove <span class="string">&#x27;/var/run&#x27;</span>: Directory not empty</span><br><span class="line">dpkg: error processing package base-files (--configure):</span><br><span class="line"> installed base-files package post-installation script subprocess returned error <span class="built_in">exit</span> status 1</span><br><span class="line">dpkg: dependency problems prevent configuration of bash:</span><br><span class="line"> bash depends on base-files (&gt;= 2.1.12); however:</span><br><span class="line">  Package base-files is not configured yet.</span><br><span class="line"></span><br><span class="line">dpkg: error processing package bash (--configure):</span><br><span class="line"> dependency problems - leaving unconfigured</span><br><span class="line">Errors were encountered <span class="keyword">while</span> processing:</span><br><span class="line"> base-files</span><br><span class="line"> bash</span><br><span class="line">No apport report written because the error message indicates its a followup error from a previous failure.</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure><p>它提示NodeJS在安装时需要访问一个名为<code>base-files</code>的组件，但是该组件在此时还没有完成“configure”。我们沿着这个信息往上追溯的话，会一直找到RootFS的初始化，此时该组件应当完成安装。</p><p>PYNQ采用Multistrap作为RootFS的初始化工具，它利用apt下载所需要的包并进行安装。<code>base-files</code>正是其中一个此时应当被安装的包，完整的包列表可以见<code>ubuntu/focal/aarch64/multistrap.config</code>。观察安装日志，可以最终定位到真正的错误原因：<code>base-files</code>的安装会用到<code>chmod</code>，这要求另一个名为<code>base-passwd</code>的包必须比它先完成“configure”，否则<code>base-files</code>的安装就会失败。简而言之，就是<code>base-files</code>依赖<code>base-passwd</code>。</p><p>那么问题来了，为什么RootFS初始化时部分包安装失败后不会报错呢？原因在<code>sdbuild/scripts/create_rootfs.sh</code>脚本中如下的两行代码抑制了<code>postinst1.sh</code>和<code>postinst2.sh</code>两个脚本的报错：</p><figure class="highlight bash"><figcaption><span>create_rootfs.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$dry_run</span> sudo -E <span class="built_in">chroot</span> <span class="variable">$target</span> bash postinst1.sh</span><br><span class="line">... <span class="comment"># other stuff</span></span><br><span class="line"><span class="variable">$dry_run</span> sudo -E <span class="built_in">chroot</span> <span class="variable">$target</span> bash postinst2.sh</span><br></pre></td></tr></table></figure><p>因此此处即使发生安装失败，程序也会继续执行下去。</p><p>更为本质的一个问题是为什么dpkg无法检测到上述两个软件包之间的依赖关系。这已经超出了PYNQ的范畴，根据Debian社区的意思大体上可以这么理解：<code>base-files</code>和<code>base-passwd</code>都是属于Essential的包，理论上它们都是必装的，因此就没有设置依赖关系。如果我们为这些必装的组件之间相互设置依赖关系的话，会陷入循环依赖的地狱。那么在安装时它们之间发生依赖冲突怎么办呢？这个问题至少在2011年就<a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=612426">有人提出过</a>，社区的结论是这个问题并不常见（多数时候<code>base-passwd</code>总比<code>base-files</code>先完成“configure”），所以不妨依靠玄学。他们认为这个问题在新的Multistrap版本上不会出现，然而并不。</p><p>这里我的解决方法是手工指定<code>dpkg --configure</code>的顺序，将<code>sdbuild/scripts/create_rootfs.sh</code>的<code>postinst1.sh</code>部分中原先的<code>dpkg --configure -a</code>修改成：</p><figure class="highlight bash"><figcaption><span>create_rootfs.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先完成base-passwd的configure</span></span><br><span class="line">dpkg --configure gcc-10-base libcrypt1 libc6 libgcc-s1 libdebconfclient0 base-passwd</span><br><span class="line"><span class="comment"># 再完成其他组件的configure</span></span><br><span class="line">dpkg --configure -a</span><br></pre></td></tr></table></figure><h3 id="python2-7-minimal安装失败"><a href="#python2-7-minimal安装失败" class="headerlink" title="python2.7-minimal安装失败"></a><code>python2.7-minimal</code>安装失败</h3><p>与上个问题类似，有时会出现<code>python2.7-minimal</code>这个包的<code>configure</code>失败。这个问题本身不是很严重，因为<code>postinst1.sh</code>和<code>postinst2.sh</code>两个脚本会各执行一遍<code>dpkg --configure -a</code>，因此第一遍中极少量没成功安装的包会在第二遍中完成安装（比如<code>cups-pk-helper</code>这个包经常如此）。然而，因为有大量包依赖于<code>python2.7-minimal</code>，一旦它安装失败后，一连串的包会一同安装失败，然后安装程序就崩了。</p><p>这里可以从报错信息中观察到，安装失败的原因是它的<code>postinst</code>脚本中用到了<code>awk</code>，然而此时<code>awk</code>这个命令还未安装。解决方法也和上个问题类似，即手工指定<code>dpkg --configure</code>的顺序，确保提供<code>awk</code>命令的包比<code>python2.7-minimal</code>先完成<code>configure</code>。有很多包都提供了<code>awk</code>命令，我这里选择了<code>mawk</code>。</p><figure class="highlight bash"><figcaption><span>create_rootfs.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg --configure &lt;... 其他需要提前`configure`的包&gt; mawk</span><br><span class="line">dpkg --configure -a</span><br></pre></td></tr></table></figure><h3 id="无法从SD卡启动，找不到RootFS"><a href="#无法从SD卡启动，找不到RootFS" class="headerlink" title="无法从SD卡启动，找不到RootFS"></a>无法从SD卡启动，找不到RootFS</h3><p>这个问题深究起来非常复杂，现象是烧写完SD卡上板卡后，无法完成开机，屏幕&#x2F;串口会显示内核错误。其中括号里的数字我这边是<code>179,2</code>和<code>179,10</code>两种情形之一（我没有彻底弄清楚这俩数字的含义）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel Panic - not syncing: VFS: Unable to mount root fs on unknown-block(179,10)</span><br></pre></td></tr></table></figure><p>关于SD卡的一系列bug都会引起这个报错。首先请确保SD卡烧写成功，烧写完成后可以在Ubuntu中挂载并尝试打开检查一下，如果不能正常打开的话重新烧写下。然后请参考以下几点依次排查。因为该报错的原因很多，我这里可能列举不全，见谅。</p><h4 id="使用dd烧写时块大小不合适"><a href="#使用dd烧写时块大小不合适" class="headerlink" title="使用dd烧写时块大小不合适"></a>使用<code>dd</code>烧写时块大小不合适</h4><p>RootFS分区的文件系统是Ext4，它在开机时会检查分区大小，因此如果在<code>dd</code>时使用过大的块大小（block size，也就是<code>bs=...</code>参数），就会无法通过分区大小的检查。</p><p>比如用4M的块大小烧写镜像的话（即<code>sudo dd bs=4M if=... of=...</code>），开机就会保错。在我这使用1M的块大小是正常的，具体命令可以看前文。</p><h4 id="SD卡的写保护"><a href="#SD卡的写保护" class="headerlink" title="SD卡的写保护"></a>SD卡的写保护</h4><p>这个问题似乎是来自于很多人使用了淘宝购买EdgeBoard FZ3A开发板时店家提供的所谓“Vivado参考设计”。这个参考设计中关于SD卡的配置存在错误，它打开了SD卡槽的写保护引脚。但是据<a href="https://whycan.com/t_3467.html">WhyCan Forum社区的文章</a>指出，EdgeBoard的PCB设计中去掉了这一引脚。因此，我们稳妥起见，可以在设备树中禁用掉写保护功能。</p><p>如前文所述，PYNQ为我们提供了一个修改设备树的接口，就是<code>boards/&lt;board_name&gt;/petalinux_bsp</code>文件夹。我们先在相应目录下创建一个设备树文件：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">mkdir</span> -p &lt;pynq_repo_dir&gt;/boards/&lt;board_name&gt;/petalinux_bsp/meta-user/recipes-bsp/device-tree/files</span><br><span class="line">❯ <span class="built_in">cd</span> &lt;pynq_repo_dir&gt;/boards/&lt;board_name&gt;/petalinux_bsp/meta-user/recipes-bsp/device-tree/files</span><br><span class="line">❯ <span class="built_in">touch</span> system-user.dtsi</span><br></pre></td></tr></table></figure><p>然后对sdhci1节点（对应于PS_SD1，即我们的SD卡槽）进行修改。完成以后，你的<code>system-user.dtsi</code>文件应该长这个样子：</p><figure class="highlight plaintext"><figcaption><span>system-user.dtsi</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/include/ &quot;system-conf.dtsi&quot;</span><br><span class="line">/ &#123; /*根节点，这里保持不变*/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;sdhci1 &#123;</span><br><span class="line">  status = &quot;okay&quot;;</span><br><span class="line">  max-frequency = &lt;50000000&gt;;</span><br><span class="line">  no-1-8-v; /*我其实不太理解这行的作用，但反正一出兼容性问题，大家就会写这个*/</span><br><span class="line">  disable-wp; /*关掉写保护功能*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上如果使用我自己做的Board Files里的Zynq Preset，是不会遇到这个问题的（不过我没试，重新编译太费时了）。</p><h4 id="Boot参数中设置了错误的root分区位置"><a href="#Boot参数中设置了错误的root分区位置" class="headerlink" title="Boot参数中设置了错误的root分区位置"></a>Boot参数中设置了错误的<code>root</code>分区位置</h4><p>PYNQ默认总是从<code>/dev/mmcblk0</code>（这个路径是PYNQ上的，不是你的宿主Ubuntu上的）启动系统，即它如果它有多个SD外设的话，SD卡要连在<code>PS_SD0</code>上。不幸的是，EdgeBoard还真的有两个SD设备，一个是我们的TF卡槽，另一个是一颗eMMC Flash芯片。默认情形下，PYNQ总是会尝试从后者启动，而我们的系统实际存放在SD卡上。</p><p>PetaLinux的Boot参数是通过设备树中的<code>/chosen/bootargs</code>条目进行配置的。默认情况下，最后镜像使用的设备树中该条目会是这样的（每个字段的先后顺序不重要）：</p><figure class="highlight plaintext"><figcaption><span>system-user.dtsi</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootargs = &quot;root=/dev/mmcblk0p2 rw earlyprintk rootfstype=ext4 rootwait devtmpfs.mount=1 uio_pdrv_genirq.of_id=\&quot;generic-uio\&quot; clk_ignore_unused&quot;;</span><br></pre></td></tr></table></figure><p>但我们希望其中的字段<code>root=/dev/mmcblk0p2</code>变成<code>root=/dev/mmcblk1p2</code>。直觉上，首先想到的是很上文一样修改<code>system-user.dtsi</code>文件，从而影响最终生成的设备树。实验会告诉你完全不起作用，最后输出也就是实际使用的设备树里还是上面这行默认值。这里大家就会遇到PYNQ这个编译流程设计的很糟糕的一点：<code>system-user.dtsi</code>这个文件中的只有一部分会起作用，至于想弄清哪部分，要么做实验，要么看懂编译源代码。比如上面对<code>&amp;sdhci1</code>节点的修改就能生效，对<code>/chosen/bootargs</code>对修改就不起作用。</p><p>生成设备树是制作BSP文件的中一部分，接下来我们来弄清楚PYNQ是如何生成最终的BSP文件的。我们先考虑用户没有提供预编译的BSP文件的情形，此时PYNQ内部会依次做这些事：</p><ol><li>建立一个空的PetaLinux项目</li><li>拷贝用户的<code>petalinux_bsp/meta-user</code>到该项目下；</li><li>读入硬件配置即<code>petalinux_bsp/hardware_project</code>中的XSA文件，生成Config文件；</li><li>构建并打包成BSP文件；</li><li>利用上一步获得的BSP文件建立一个新的PetaLinux项目；</li><li>直接在脚本中修改Config文件，加入一些配置；</li><li>重新运行<code>petalinux-config</code>生成新的Config文件；</li><li>开始各种build，最终生成我们需要的BOOT.bin。</li></ol><p>其中步骤1、2、3、4在<code>sdbuild/scripts/create_bsp.sh</code>脚本中进行，步骤5、6、7、8在<code>sdbuild/Makefile</code>中进行。如果用户指定了预编译的BSP文件，就把上文中的第1步换成“利用用户提供的BSP文件建立一个新的PetaLinux项目”。这里最令人困惑的地方是，为什么要进行两次“create-config-build”的流程，至少我没有看出它这么做的必要性。这样一通操作之后，用户在<code>petalinux_bsp/meta-user</code>的子目录下的<code>system-user.dtsi</code>文件中修改的一些设备树节点（对应上文步骤2），会在步骤6中被新引入的一些设备树文件冲刷掉。步骤6通过<code>CONFIG_USER_LAYER_0</code>这一设置混入了一些新的设备树文件，这些额外的设备树文件位于<code>sdbuild/boot/meta-pynq/recipes-bsp/device-tree</code>。就Boot参数而言，这里边的<code>pynq_bootargs.dtsi</code>文件提供了前述的默认<code>/chosen/bootargs</code>。因此无论我们在<code>system-user.dtsi</code>文件中如何修改<code>/chosen/bootargs</code>，最终都会被覆盖掉。因此，我们的解决方案很简单，修改下该文件，将其中的<code>root=/dev/mmcblk0p2</code>变成<code>root=/dev/mmcblk1p2</code>。因为这个文件只有几行，改动也很小，我就不把代码贴出来了。</p><p>除了修改<code>pynq_bootargs.dtsi</code>，我们还需要修改<code>sdbuild/Makefile</code>，将下面这行代码中的<code>mmcblk0p2</code>变成<code>mmcblk1p2</code>。</p><figure class="highlight bash"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_SDROOT_DEV=&quot;/dev/mmcblk0p2&quot;&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br></pre></td></tr></table></figure><p>我这里提供另一个有趣的思路，<code>sdhci0</code>和<code>sdhci1</code>在设备树文件中是俩alias，我们可以在设备树中交换它们的值（<code>/amba/mmc@ff160000</code>和<code>/amba/mmc@ff170000</code>）。不过我没有做过实验。</p><!-- 标准的PetaLinux项目中，我们通过`petalinux-config`的GUI配置界面 --><h3 id="UART串口不工作"><a href="#UART串口不工作" class="headerlink" title="UART串口不工作"></a>UART串口不工作</h3><p>EdgeBoard FZ3A有两个UART串口，一个是BT1120连接件的一部分，另一个转成了USB接口。我们用来连接电脑进行交互的串口，显然希望是后者。和前面SD卡的情况相似，PYNQ默认PS_UART0作为输出串口，而我们实际想要的是PS_UART1。解决这个问题的方法很简单，在上面修改<code>CONFIG_SUBSYSTEM_SDROOT_DEV</code>的那行后面加上以下几行：</p><figure class="highlight bash"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_PMUFW_SERIAL_PSU_UART_1_SELECT=y&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_FSBL_SERIAL_PSU_UART_1_SELECT=y&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_ATF_SERIAL_PSU_UART_1_SELECT=y&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_SERIAL_PSU_UART_1_SELECT=y&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_PRIMARY_SD_PSU_SD_1_SELECT=y&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br></pre></td></tr></table></figure><h3 id="dash-preinst找不到"><a href="#dash-preinst找不到" class="headerlink" title="dash.preinst找不到"></a><code>dash.preinst</code>找不到</h3><p>RootFS的编译脚本（即<code>create_rootfs.sh</code>）会在前面提到的<code>postinst1.sh</code>和<code>postinst2.sh</code>两个脚本执行中提示<code>dash.preinst</code>执行失败，原因是<code>/var/lib/dpkg/info/dash.preinst</code>找不到。该错误的原因仅仅是上游已经把<code>dash.preinst</code>这个脚本删除了（可参考<a href="https://unix.stackexchange.com/questions/558844/no-var-lib-dpkg-info-dash-preinst-in-buster">此文</a>）。因此这里执行该脚本的三行代码都是多余的，直接删除即可。即使不删除，它们也应当不会引起其他异常（除了在终端里输出一些错误信息）。</p><h3 id="RootFS分区磁盘容量不足"><a href="#RootFS分区磁盘容量不足" class="headerlink" title="RootFS分区磁盘容量不足"></a>RootFS分区磁盘容量不足</h3><p>PYNQ在编译的最后，会对最终的镜像的RootFS分区进行扩容。扩容主要是增加一些用户空间，以及给操作系统本身腾出一些地方放临时文件。扩容操作是在<code>sdbuild/scripts/resize_umount.sh</code>脚本中进行（别问我为什么文件名中unmount拼写错了，源代码如此）。PYNQ的开发者很可能是为了尽量使最终镜像小于8GB，所以只额外扩容了300MB。</p><p>很不幸的是，这300MB实在是捉襟见肘，经常开完机就用得七七八八了。极端情况下，可能不足以支撑Jupyter成功运行，现象是能够ssh访问，但浏览器完全打不开Jupyter。排查方法是，上电后通过ssh进入板上的操作系统，执行<code>df</code>，观察<code>/</code>分区的磁盘占用情况。</p><p>我的SD卡是64GB的，因此，我直接修改了<code>resize_umount.sh</code>脚本，将扩容空间从300MB改成了3000MB。你可以根据你的SD卡容量自由发挥，当然没必要太大，否则烧写SD卡会变得很慢。具体到代码上，在该脚本中找到下面一行代码，把其中的300改成任意你想要的数字。</p><figure class="highlight bash"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_size=$(( <span class="variable">$used_size</span> + (<span class="number">300</span> * <span class="number">1024</span>) ))</span><br></pre></td></tr></table></figure><h3 id="各种文件下载失败"><a href="#各种文件下载失败" class="headerlink" title="各种文件下载失败"></a>各种文件下载失败</h3><p>多数都是网络环境的问题，可以先阅读下一节。如果还是解决不了的话，请联系公司的IT工程师协助解决。</p><h2 id="Speedup！编译提速"><a href="#Speedup！编译提速" class="headerlink" title="Speedup！编译提速"></a>Speedup！编译提速</h2><p>在我的破笔记本上，完整的一次PYNQ流程需要整一个下午，中间还需要多次输入管理员密码。因为我们很难一次成功，所以需要不断地重新进行编译流程，所以我们总希望整个编译能够进行地快一些。接下来我们开始着手加速编译流程。</p><h3 id="跳过输入管理员密码"><a href="#跳过输入管理员密码" class="headerlink" title="跳过输入管理员密码"></a>跳过输入管理员密码</h3><p>PYNQ编译中会频繁使用<code>sudo</code>命令，需要我们不断地输入密码，否则程序就一直卡在那等待。Ubuntu默认两次<code>sudo</code>的时间间隔超过15分钟左右就要重新输入密码，我们可以把这个时间延长一些（比如这里我延长到了2小时）。</p><p>首先在<code>/etc/sudoers</code>中找到如下一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults    env_reset</span><br></pre></td></tr></table></figure><p>将它改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults    env_reset,timestamp_timeout=120</span><br></pre></td></tr></table></figure><h3 id="为Multistrap更换下载源"><a href="#为Multistrap更换下载源" class="headerlink" title="为Multistrap更换下载源"></a>为Multistrap更换下载源</h3><p>Multistrap利用apt下载各种需要的包来构建RootFS。默认情况下，apt会从官方ports源（<code>http://ports.ubuntu.com/ubuntu-ports</code>）下载文件，时间很长且经常失败。换源的方法非常方便，直接在编译开始前声明<code>PYNQ_UBUNTU_REPO</code>环境变量即可。例如换成清华源：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">export</span> PYNQ_UBUNTU_REPO=http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports</span><br></pre></td></tr></table></figure><p>注意这里必须是<code>http</code>而不是<code>https</code>。</p><h3 id="为CrossTool-NG建立本地缓存"><a href="#为CrossTool-NG建立本地缓存" class="headerlink" title="为CrossTool-NG建立本地缓存"></a>为CrossTool-NG建立本地缓存</h3><p>CrossTool-NG每次运行时会从云端下载很多包（主要是各种源代码）。根据其文档的指示，我们可以建立一个本地的缓存文件夹。当需要下载的包本地已经缓存时，它就会跳过下载，从而节省时间。CrossTool-NG的配置文件在<code>sdbuild/packages/gcc-mb/samples/&lt;compile_targets&gt;/crosstool.config</code>，在其最后加上两行：</p><figure class="highlight plaintext"><figcaption><span>crosstool.config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CT_SAVE_TARBALLS=y</span><br><span class="line">CT_LOCAL_TARBALLS_DIR=&lt;somewhere_to_put_downloaded_files&gt;</span><br></pre></td></tr></table></figure><p>注意请在运行前保证该路径是个文件夹，且具有读写权限。</p><h3 id="为PetaLinux建立本地SSTATE缓存"><a href="#为PetaLinux建立本地SSTATE缓存" class="headerlink" title="为PetaLinux建立本地SSTATE缓存"></a>为PetaLinux建立本地SSTATE缓存</h3><p>首先去<a href="https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools/2020-2.html">Xilinx官网</a>下载sstate-cache文件。注意版本要和PetaLinux保持一致（本文中我们用的是2020.2）。</p><p>因为EdgeBoard FZ3A板载的Zynq芯片是ARM64架构，因此为了节约空间，就只下载“aarch64 sstate-cache”和“downloads”两个包（加起来也超过60GB了）。然后我们将它们解压缩，并把路径添加到<code>petalinux_bsp/meta-user/conf/petalinuxbsp.conf</code>：</p><figure class="highlight bash"><figcaption><span>petalinuxbsp.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DL_DIR = <span class="string">&quot;&lt;sstate_extract_dir&gt;/2020.2/downloads&quot;</span></span><br><span class="line">SSTATE_DIR = <span class="string">&quot;&lt;sstate_extract_dir&gt;/2020.2/sstate-cache/aarch64&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除boards目录下Pynq-Z2以外的开发板"><a href="#删除boards目录下Pynq-Z2以外的开发板" class="headerlink" title="删除boards目录下Pynq-Z2以外的开发板"></a>删除<code>boards</code>目录下Pynq-Z2以外的开发板</h3><p>因为我们的编译目标是EdgeBoard FZ3A，所以<code>boards</code>目录下的<code>Pynq-Z1</code>、<code>Pynq-Z2</code>、<code>ZCU104</code>三个目录对我们来说就是多余的。然而PYNQ在编译过程中会遍历<code>boards</code>目录下的各个开发板并试图生成比特流文件。其中<code>Pynq-Z2</code>的输出会在<code>pynq</code>自身编译时用到，另外两个开发板的相关文件的编译纯属是浪费时间（关键是这步还特别费时），我怀疑这是个bug。因此，我们可以将<code>Pynq-Z1</code>、<code>ZCU104</code>两个文件夹删除。</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> &lt;pynq_repo_dir&gt;</span><br><span class="line">❯ <span class="built_in">rm</span> -rf boards/Pynq-Z1 boards/ZCU104</span><br></pre></td></tr></table></figure><p>完成之后，务必要提交到本地的Git版本历史中，否则不起作用（这是因为作者用<code>git clone</code>代替了<code>cp</code>）。</p><h3 id="跳过boards-Pynq-Z2中各个Overlay生成比特流"><a href="#跳过boards-Pynq-Z2中各个Overlay生成比特流" class="headerlink" title="跳过boards/Pynq-Z2中各个Overlay生成比特流"></a>跳过<code>boards/Pynq-Z2</code>中各个<code>Overlay</code>生成比特流</h3><p><code>pynq</code>作为一个Python的包，在编译过程中是要和其他packages一起安装到镜像中的。进行这一步时，它会将Pynq的本地repo先复制到<code>sdbuild/build/PYNQ</code>中，然后再运行其中的<code>build.sh</code>。观察这个脚本，我们可以看到PYNQ在编译<code>Pynq-Z2/logictools</code>和<code>Pynq-Z2/base</code>两个<code>Overlay</code>文件夹时，会先检查其中是否已存在同名的<code>.bit</code>、<code>.hwh</code>、<code>.xsa</code>文件，存在的话就跳过生成比特流的过程（即综合、布局布线等）。因此，我们可以先按照正常流程<code>make BOARDDIR=... BOARDS=...</code>，然后把生成的相关文件拷贝到原始的<code>boards/Pynq-Z2</code>目录中的对应文件夹下：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制.xsa文件，.bit/.hwh文件类似处理</span></span><br><span class="line">❯ <span class="built_in">cp</span> &lt;pynq_repo_dir&gt;/sdbuild/build/PYNQ/boards/Pynq-Z2/logictools/logictools.xsa &lt;pynq_repo_dir&gt;/boards/Pynq-Z2/logictools/</span><br><span class="line">❯ <span class="built_in">cp</span> &lt;pynq_repo_dir&gt;/sdbuild/build/PYNQ/boards/Pynq-Z2/base/base.xsa &lt;pynq_repo_dir&gt;/boards/Pynq-Z2/base/</span><br></pre></td></tr></table></figure><p>注意这里的路径，是从<code>sdbuild/build</code>中的<code>PYNQ</code>复制到原始的<code>PYNQ</code>。和前面一样，要提交到Git版本历史中才会生效。</p><p>另外，经过实验证明，这里<code>.xsa</code>和<code>.bit</code>文件需要是同一次编译中产生，否则会发生一些奇怪且难以定位的错误。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>搭建这个个人博客也有几年了，本想闲暇时写些技术文章，但没能持之以恒地保持输出。中间也曾断断续续写过一些论文阅读笔记，但都没有坚持下来。一方面是因为总担心自己粗浅的专业认识贻笑大方，另一方面是实验室的项目也确实不太合适作为写作素材，便一直没有动笔。EdgeBoard的事情我在去年COVID疫情期间动工后就一直搁置了，结果发现最近有不少人关心这个事情，就花了些时间算是给它画了个句号。我也以此为契机，提起了笔记录下整个过程。希望能够对大家有所帮助。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PYNQ是我很喜欢的一个FPGA开源工具。它将Zynq上的各种硬件资源用Python封装了起来，允许用户通过Jupytor Notebook远程调试FPGA。将PYNQ移植到Baidu EdgeBoard上是我去年在COVID疫情期间开的坑（具体请参看&lt;a href=&quot;https://github.com/zhutmost/edgeboard&quot;&gt;我的GitHub&lt;/a&gt;），但中间遇到的小问题有点多，便一直没有完全填上。我最近抽出了些时间重新拾起了这个事情，就顺便把整个过程和遇到的问题都记录下来，以飨后来者。&lt;/p&gt;
&lt;p&gt;相关源代码已开源至&lt;a href=&quot;https://github.com/zhutmost/edgeboard&quot;&gt;Github&lt;/a&gt;，预编译PYNQ镜像文件我也已上传至&lt;a href=&quot;https://www.aliyundrive.com/s/6biJpMiKrpD&quot;&gt;阿里云盘&lt;/a&gt;。因为设备有限，我没有为这个镜像进行所有外设的上板测试。如果你发现了任何问题，欢迎和我联系。&lt;/p&gt;</summary>
    
    
    
    <category term="Engineering" scheme="https://zhutmost.com/categories/Engineering/"/>
    
    
    <category term="FPGA" scheme="https://zhutmost.com/tags/FPGA/"/>
    
    <category term="PYNQ" scheme="https://zhutmost.com/tags/PYNQ/"/>
    
  </entry>
  
</feed>
