<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Haozhe Zhu&#39;s Blog</title>
  
  
  <link href="https://zhutmost.com/atom.xml" rel="self"/>
  
  <link href="https://zhutmost.com/"/>
  <updated>2023-03-30T08:54:22.044Z</updated>
  <id>https://zhutmost.com/</id>
  
  <author>
    <name>Haozhe Zhu</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>2023年智能芯片领域会议概览</title>
    <link href="https://zhutmost.com/Research/asic-conf-ddl/"/>
    <id>https://zhutmost.com/Research/asic-conf-ddl/</id>
    <published>2022-11-13T06:31:19.000Z</published>
    <updated>2023-03-30T08:54:22.044Z</updated>
    
    <content type="html"><![CDATA[<p>为了准确把握每一个学术交流（摸鱼）的机会，本文收集了智能芯片领域（固态电路、体系结构等）的相关学术会议的投稿信息，包括召开时间、地点、截稿时间等。之后，我将尽量保持本文持续更新。</p><span id="more"></span><p>由于多数会议的投稿截稿时间都会延期一至两周，因此下表中的截稿时间通常只是个大约时间。</p><h2 id="固态电路"><a href="#固态电路" class="headerlink" title="固态电路"></a>固态电路</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">ISSCC’23</td><td>San Francisco, CA, US</td><td>2023.02.19</td><td>2022.09.07</td><td><a href="https://www.isscc.org/">Link</a></td></tr><tr><td align="center">VLSI’23</td><td>Kyoto, Japan</td><td>2023.06.11</td><td>2023.02.01</td><td><a href="https://www.vlsisymposium.org/">Link</a></td></tr><tr><td align="center">ESSCIRC’23</td><td>Lisbon, Portugal</td><td>2023.09.11</td><td>2023.04.14</td><td><a href="https://www.esscirc-essderc2023.org/">Link</a></td></tr><tr><td align="center">ASSCC’23</td><td>Haikou, China</td><td>2023.11.05</td><td>2023.06.05</td><td><a href="https://www.a-sscc2023.com/">Link</a></td></tr><tr><td align="center">CICC’23</td><td>San Antonio, TX, US</td><td>2023.04.23</td><td>2022.11.14</td><td><a href="https://www.ieee-cicc.org/">Link</a></td></tr><tr><td align="center">HOTCHIPS’23</td><td>San Francisco, CA, US</td><td>2023.08.27</td><td>2023.03.22</td><td><a href="https://hotchips.org/">Link</a></td></tr></tbody></table><h2 id="体系结构"><a href="#体系结构" class="headerlink" title="体系结构"></a>体系结构</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">ISCA’23</td><td>Orlando, FL, USA</td><td>2022.11.14</td><td>2023.06.17</td><td><a href="https://iscaconf.org/isca2023/">Link</a></td></tr><tr><td align="center">MICRO’23</td><td>-</td><td>-</td><td>-</td><td><a href="https://www.microarch.org/">Link</a></td></tr><tr><td align="center">HPCA’23</td><td>Montreal, Canada</td><td>2023.02.25</td><td>2022.08.01</td><td><a href="https://hpca-conf.org/2023">Link</a></td></tr><tr><td align="center">DAC’23</td><td>San Francisco, CA, US</td><td>2023.07.09</td><td>2022.11.14</td><td><a href="https://www.dac.com/">Link</a></td></tr></tbody></table><h2 id="机器视觉"><a href="#机器视觉" class="headerlink" title="机器视觉"></a>机器视觉</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">CVPR’23</td><td>Vancouver, Canada</td><td>2023.06.18</td><td>2022.11.04</td><td><a href="https://cvpr2023.thecvf.com/">Link</a></td></tr><tr><td align="center">IROS’23</td><td>Detroit, MI, US</td><td>2023.10.01</td><td>2023.03.01</td><td><a href="https://ieee-iros.org/">Link</a></td></tr><tr><td align="center">ICRA’23</td><td>London, UK</td><td>2023.05.29</td><td>2022.08.05</td><td><a href="https://www.icra2023.org/">Link</a></td></tr></tbody></table><h2 id="其他会议"><a href="#其他会议" class="headerlink" title="其他会议"></a>其他会议</h2><table><thead><tr><th align="center">会议</th><th>地点</th><th>召开时间</th><th>截稿时间</th><th>网站链接</th></tr></thead><tbody><tr><td align="center">ISCAS’23</td><td>Monterey, CA, US</td><td>2023.05.21</td><td>2022.11.07</td><td><a href="https://iscas2023.org/">Link</a></td></tr><tr><td align="center">AICAS’23</td><td>Hangzhou, China</td><td>2023.06.11</td><td>2023.02.03</td><td><a href="http://www.aicas2023.org/">Link</a></td></tr><tr><td align="center">APCCAS’23</td><td>Hyderabad, India</td><td>2023.11.20</td><td>2023.06.04</td><td><a href="https://www.apccas2023.org/">Link</a></td></tr><tr><td align="center">MWSCAS’23</td><td>Phoenix, AZ, US</td><td>2023.04.07</td><td>2022.08.06</td><td><a href="https://www.mwscas2023.org/">Link</a></td></tr><tr><td align="center">BioCAS’23</td><td>Toronta, Canada</td><td>2023.10.19</td><td>2023.06.09</td><td><a href="https://2023.ieee-biocas.org/">Link</a></td></tr><tr><td align="center">GLSVLSI’23</td><td>Knoxville, TN, US</td><td>2023.06.05</td><td>2023.02.06</td><td><a href="https://www.glsvlsi.org/">Link</a></td></tr><tr><td align="center">ICCAD’23</td><td>Rome, Italy</td><td>2023.05.10</td><td>2022.12.31</td><td><a href="https://www.iccad-conf.com/">Link</a></td></tr><tr><td align="center">ASP-DAC’23</td><td>Tokyo, Japan</td><td>2023.01.16</td><td>2022.07.24</td><td><a href="https://www.aspdac.com/aspdac2023">Link</a></td></tr><tr><td align="center">DATE’23</td><td>Antwerp, Belgium</td><td>2023.04.17</td><td>2022.09.18</td><td><a href="https://www.date-conference.com/">Link</a></td></tr><tr><td align="center">MLSys’23</td><td>Southern FL, US</td><td>2023.06.04</td><td>2022.10.28</td><td><a href="https://mlsys.org/">Link</a></td></tr><tr><td align="center">FPGA’23</td><td>Monterey, CA, US</td><td>2023.02.12</td><td>2022.09.23</td><td><a href="https://www.isfpga.org/">Link</a></td></tr><tr><td align="center">FPT’23</td><td>-</td><td>-</td><td>-</td><td><a href="http://www.icfpt.org/">Link</a></td></tr><tr><td align="center">FPL’23</td><td>Gothenburg, Sweden</td><td>2023.09.04</td><td>2023.03.13</td><td><a href="https://2023.fpl.org/">Link</a></td></tr></tbody></table><p>祝大家投稿顺利～</p><p><a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-size:12px;line-height:1.2;display:inline-block;border-radius:3px" href="https://unsplash.com/photos/SAQl58G-RYs" target="_blank" rel="noopener noreferrer" title="Harvest Fields in Westerham, Kent, 1880-1910 by Helen Allingham"><span style="display:inline-block;padding:2px 3px"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white" viewBox="0 0 32 32"><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px">photoed by Birmingham Museums</span></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;为了准确把握每一个学术交流（摸鱼）的机会，本文收集了智能芯片领域（固态电路、体系结构等）的相关学术会议的投稿信息，包括召开时间、地点、截稿时间等。之后，我将尽量保持本文持续更新。&lt;/p&gt;</summary>
    
    
    
    <category term="Research" scheme="https://zhutmost.com/categories/Research/"/>
    
    
    <category term="Paper Lives Matter" scheme="https://zhutmost.com/tags/Paper-Lives-Matter/"/>
    
    <category term="AI Chip" scheme="https://zhutmost.com/tags/AI-Chip/"/>
    
  </entry>
  
  <entry>
    <title>SSH通过443端口连接GitHub</title>
    <link href="https://zhutmost.com/Engineering/github-ssh-443/"/>
    <id>https://zhutmost.com/Engineering/github-ssh-443/</id>
    <published>2022-07-30T04:00:00.000Z</published>
    <updated>2023-01-05T07:58:22.277Z</updated>
    
    <content type="html"><![CDATA[<p>GitHub提供了两种协议供用户使用Git连接——SSH和HTTPS。理论上我可以随意选择两者之一连接到我在GitHub上的代码仓库，无论是将云端的仓库<code>clone</code>到本地，还是将本地的修改<code>push</code>到云端。然而，出于一些奇奇怪怪的原因，我所在的办公网络环境禁止了22端口，而22端口正是GitHub提供SSH访问的端口号。尽管可以换用HTTPS协议，但无论如何将我电脑上的所有代码仓库的上游都从<code>git@github.com:...</code>修改称<code>https://github.com/...</code>仍然是一个繁重的体力活。</p><p>为了一劳永逸地解决这个问题，最理想的解决方式是让Git的SSH协议改用22以外的其他端口连接GitHub。</p><span id="more"></span><h2 id="SSH连接失败"><a href="#SSH连接失败" class="headerlink" title="SSH连接失败"></a>SSH连接失败</h2><p>我们在<code>clone</code>GitHub上的代码仓库时，可以看到GitHub提供了两种不同的链接（以我的SpinalHDL模版仓库为例）：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/zhutmost/spinalhdl-template.git <span class="comment"># HTTPS</span></span><br><span class="line">git <span class="built_in">clone</span> git@github.com:zhutmost/spinalhdl-template.git <span class="comment"># SSH</span></span><br></pre></td></tr></table></figure><p>其中第一种方式，即HTTPS协议，一般总能可以工作（只要能在浏览器里打开GitHub），而后者依赖SSH的正常工作。因为我的网络环境阻断了22端口的连接，所以我测试GitHub的SSH连接时会出现以下报错：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh -T git@github.com</span><br><span class="line">kex_exchange_identification: Connection closed by remote host</span><br><span class="line">Connection closed by xx.xx.xx.xx port 22</span><br></pre></td></tr></table></figure><p>而在理想情况下，上述命令应当输出：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh -T git@github.com</span><br><span class="line">Hi zhutmost! You<span class="string">&#x27;ve successfully authenticated, but GitHub does not provide shell access.</span></span><br></pre></td></tr></table></figure><h2 id="奇妙的冒名顶替"><a href="#奇妙的冒名顶替" class="headerlink" title="奇妙的冒名顶替"></a>奇妙的冒名顶替</h2><p>仔细发掘<a href="https://docs.github.com/en/authentication/troubleshooting-ssh/using-ssh-over-the-https-port">GitHub的文档</a>，可以发现GitHub在另一个域名（ssh.github.com）上提供了一个443端口的SSH服务。显然，防火墙一般不会阻拦443端口（只要能浏览GitHub网站就能连上），可以用下面的命令进行测试：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ ssh -T -p 443 git@ssh.github.com</span><br></pre></td></tr></table></figure><p>为了让Git也能通过上述端口用SSH访问GitHub，我们为上述SSH连接方式设置一个别名。首先找到SSH的配置文件，它的路径一般是<code>~/.ssh/config</code>，如果这个文件不存在的话也可以创建一个。然后，在其中增加以下内容：</p><figure class="highlight text"><figcaption><span>ssh_config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Host github.com</span><br><span class="line">  HostName ssh.github.com</span><br><span class="line">  User git</span><br><span class="line">  Port 443</span><br></pre></td></tr></table></figure><p>其中，<code>Host</code>是别名，<code>HostName</code>是实际的域名地址，<code>Port</code>是端口号。因为我希望当我在用SSH连接github.com时，实际访问的是ssh.github.com，所以<code>Host</code>和<code>HostName</code>分别设置成这两个域名（注意不要颠倒顺序）。</p><p>如此一来，ssh.github.com就成为了github.com的“冒名顶替”者。当Git通过SSH协议试图访问github.com的时候，SSH会发现它是ssh.github.com的别名，因此会用443端口实际连接到后者。这样，就绕开了本地网路环境对22端口的限制。</p><p>（我之所以使用上述方法，是因为我的网络情况比较复杂。建议公司的朋友在使用暗渡陈仓之策前，先和IT部门确认下是否合规。）</p><p><a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-size:12px;line-height:1.2;display:inline-block;border-radius:3px" href="https://unsplash.com/photos/0pJPixfGfVo" target="_blank" rel="noopener noreferrer" title="Near Sorrento, 1863 by John Brett"><span style="display:inline-block;padding:2px 3px"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white" viewBox="0 0 32 32"><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px">photoed by Birmingham Museums</span></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;GitHub提供了两种协议供用户使用Git连接——SSH和HTTPS。理论上我可以随意选择两者之一连接到我在GitHub上的代码仓库，无论是将云端的仓库&lt;code&gt;clone&lt;/code&gt;到本地，还是将本地的修改&lt;code&gt;push&lt;/code&gt;到云端。然而，出于一些奇奇怪怪的原因，我所在的办公网络环境禁止了22端口，而22端口正是GitHub提供SSH访问的端口号。尽管可以换用HTTPS协议，但无论如何将我电脑上的所有代码仓库的上游都从&lt;code&gt;git@github.com:...&lt;/code&gt;修改称&lt;code&gt;https://github.com/...&lt;/code&gt;仍然是一个繁重的体力活。&lt;/p&gt;
&lt;p&gt;为了一劳永逸地解决这个问题，最理想的解决方式是让Git的SSH协议改用22以外的其他端口连接GitHub。&lt;/p&gt;</summary>
    
    
    
    <category term="Engineering" scheme="https://zhutmost.com/categories/Engineering/"/>
    
    
    <category term="GitHub" scheme="https://zhutmost.com/tags/GitHub/"/>
    
  </entry>
  
  <entry>
    <title>EdgeBoard的PYNQ移植</title>
    <link href="https://zhutmost.com/Engineering/pynq-compile/"/>
    <id>https://zhutmost.com/Engineering/pynq-compile/</id>
    <published>2021-08-12T14:43:32.000Z</published>
    <updated>2023-01-05T07:56:30.969Z</updated>
    
    <content type="html"><![CDATA[<p>PYNQ是我很喜欢的一个FPGA开源工具。它将Zynq上的各种硬件资源用Python封装了起来，允许用户通过Jupytor Notebook远程调试FPGA。将PYNQ移植到Baidu EdgeBoard上是我去年在COVID疫情期间开的坑（具体请参看<a href="https://github.com/zhutmost/edgeboard">我的GitHub</a>），但中间遇到的小问题有点多，便一直没有完全填上。我最近抽出了些时间重新拾起了这个事情，就顺便把整个过程和遇到的问题都记录下来，以飨后来者。</p><p>相关源代码已开源至<a href="https://github.com/zhutmost/edgeboard">Github</a>，预编译PYNQ镜像文件我也已上传至<a href="https://www.aliyundrive.com/s/6biJpMiKrpD">阿里云盘</a>。因为设备有限，我没有为这个镜像进行所有外设的上板测试。如果你发现了任何问题，欢迎和我联系。</p><span id="more"></span><p>PYNQ官方提供了<a href="https://pynq.readthedocs.io/en/latest/pynq_sd_card.html">SD卡镜像编译的文档</a>，因此一些比较明确的步骤我可能不会详述，请搭配官方文档阅读。</p><p>为了避免混淆，这里先澄清一下很多朋友的一个小误解：本文中的PYNQ指的是PYNQ框架（本质上是一个Ubuntu），而非那两个粉色的开发板（PYNQ-Z1和PYNQ-Z2）。PYNQ可以部署在PYNQ-Z1和PYNQ-Z2上，也可以部署在其他Zynq系列的FPGA上。</p><h2 id="开始之前"><a href="#开始之前" class="headerlink" title="开始之前"></a>开始之前</h2><p>Xilinx提供了PYNQ-Z1、PYNQ-Z2、ZCU104等开发板的镜像，可以直接从PYNQ网站上下载到，具体列表可以在<a href="http://pynq.io/board.html">PYNQ的下载页面</a>找到（也包括Ultra96等第三方开发板）。如果我们想要在此外的开发板（比如本文中的EdgeBoard Lite）上使用PYNQ，就需要自己编译PYNQ镜像。</p><p>本文的编译目标是PYNQ v2.7。本文写作时（2021年8月）PYNQ2.7的开发已经完成，但是还没有合入主线分支，文档也没有更新（但差别不大，反正各种奇奇怪怪的bug本来也不会写在文档里）。每次大版本（即2.X）更新后，随着时间推移，依赖软件包之间会出现五花八门的兼容性问题，这些问题很可能要到下一次PYNQ大版本更新才会一次性修复。这个问题主要得归咎于Xilinx官方，PYNQ的编译中依赖的很多软件都不指定特定版本。因此，如果你看到本文时，已是很久之后，文章中遇到的问题和你遇到的可能不尽相同。</p><p>硬件上，除了Edgeboard本身，我准备了一台半淘汰的笔记本搭建编译环境。这个不是很重要（虚拟机也不是不可以），唯一需要确认的是剩余磁盘空间要够大（大约200GB）。</p><p>PYNQ v2.7需要Vivado&#x2F;Vitis&#x2F;PetaLinux的版本为2020.2。我的操作系统是Ubuntu 18.04.5 LTS。Vivado&#x2F;Vitis 2020.2最高支持Ubuntu 18.04.4，安装时需要修改<code>/etc/os-release</code>骗过安装程序。这里操作系统的版本建议请严格按照Xilinx的安装指南，我不建议你和我一样操作。</p><p>编译过程中需要从互联网上下载大量依赖组件，请确保你能够自由访问互联网。</p><h2 id="理想的编译过程"><a href="#理想的编译过程" class="headerlink" title="理想的编译过程"></a>理想的编译过程</h2><h3 id="设置PYNQ环境"><a href="#设置PYNQ环境" class="headerlink" title="设置PYNQ环境"></a>设置PYNQ环境</h3><p>首先将PYNQ的GitHub Repo复制到本地，并切换到<code>image_v2.7</code>分支。</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ git <span class="built_in">clone</span> https://github.com/Xilinx/PYNQ.git pynq</span><br><span class="line">❯ <span class="built_in">cd</span> pynq</span><br><span class="line">❯ git checkout image_v2.7</span><br></pre></td></tr></table></figure><p>我们接下来的主要工作都在<code>sdbuild</code>目录下进行。先运行<code>scripts/setup_host.sh</code>，它会用apt安装各种需要的包，以及下载QEMU和CrossTool-NG。</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">source</span> ./scripts/setup_host.sh</span><br></pre></td></tr></table></figure><p>这个脚本运行需要很久的时间（主要是因为下载QEMU和CrossTool-NG的安装包），但好在只需要运行一次。</p><p>后续编译过程还会依赖Ninja，然而该脚本中没有安装，因此我们手动安装下。</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install ninja-build</span><br></pre></td></tr></table></figure><p>到这里，Xilinx全家桶需要的各种依赖包也安装完成了，接下来就可以安装Xilinx全家桶了。</p><h3 id="安装Xilinx全家桶"><a href="#安装Xilinx全家桶" class="headerlink" title="安装Xilinx全家桶"></a>安装Xilinx全家桶</h3><p>我们需要安装Vivado、Vitis、PetaLinux三个软件。按照PYNQ v2.7的版本要求，三者的版本都必须是2020.2。这里需要注意的是，不要使用管理员权限安装。</p><p>Vivado和Vitis是通过同一个安装程序安装的，安装时命令行运行<code>./xsetup</code>，勾选需要的组件即可。</p><p>PetaLinux安装的命令如下：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ petalinux-v2020.2-final-installer.run --<span class="built_in">dir</span> &lt;xilinx_install_dir&gt;/petalinux/2020.2 --platform <span class="string">&quot;aarch64 arm&quot;</span></span><br></pre></td></tr></table></figure><p>具体安装选项可以参考<a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1144-petalinux-tools-reference-guide.pdf">UG1144</a>。这里存在一个坑，PetaLinux的安装程序允许用户任意指定安装位置，但是PYNQ之前的版本默认却要求它的路径必须是<code>.../2020.2/</code>的形式（v2.7有无修复不确定，我没有去测试）。</p><p>安装完成后，我们需要将下面几行代码加入<code>.bashrc</code>（也可以每次打开命令行手动执行）。这样一来，就可以在命令行中运行这些软件了。</p><figure class="highlight bash"><figcaption><span>.bashrc</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">source</span> &lt;xilinx_install_dir&gt;/petalinux/2020.2/settings.sh</span><br><span class="line"><span class="built_in">source</span> &lt;xilinx_install_dir&gt;/Vivado/2020.2/settings64.sh</span><br><span class="line"><span class="built_in">source</span> &lt;xilinx_install_dir&gt;/Vitis/2020.2/settings64.sh</span><br></pre></td></tr></table></figure><h3 id="添加自定义开发板"><a href="#添加自定义开发板" class="headerlink" title="添加自定义开发板"></a>添加自定义开发板</h3><p>PYNQ在<code>boards</code>文件夹下预置了<code>Pynq-Z1</code>、<code>Pynq-Z2</code>、<code>ZCU104</code>三个与对应开发板同名的文件夹。它们的内部结构大同小异，主要分成以下五个部分：</p><ol><li><code>notebooks</code>；</li><li><code>petalinux_bsp</code>；</li><li><code>packages</code>；</li><li><code>base</code>、<code>logictools</code>等<code>Overlay</code>文件夹；</li><li><code>&lt;board_name&gt;.spec</code>。</li></ol><p>下面简单介绍下这些文件和文件夹的功能，具体的细节（如果你需要定制一些复杂的东西）还请自行阅读PYNQ的编译脚本源代码。</p><p><code>notebooks</code>文件夹会原样复制到最终的用户目录下，每次大家打开Jupyter Notebook后看到的就是它。这个文件夹里的内容不是很重要，一般都是放些教程。</p><p><code>petalinux_bsp</code>文件夹用于PetaLinux生成BSP，它只在<code>sdbuild/scripts/create_bsp.sh</code>脚本中用到。该文件夹里边包括两个文件夹<code>meta-user</code>、<code>hardware_project</code>。其中，<code>meta-user</code>文件夹会被复制到PetaLinux项目文件夹下的<code>project-spec/meta-user</code>，里面放设备树文件、各种用户配置等（如果你对PetaLinux项目的目录结构不了解的话可以参考<a href="https://www.xilinx.com/support/documentation/sw_manuals/xilinx2020_2/ug1144-petalinux-tools-reference-guide.pdf">UG1144</a>）。<code>hardware_project</code>里需要放<code>.xsa</code>硬件描述文件（该文件由Vivado导出），或者也可以放一些脚本（至少包括一个Makefile）供PetaLinux实时地生成<code>.xsa</code>文件。如果用户在<code>&lt;board_name&gt;.spec</code>中指定了BSP，那么<code>hardware_project</code>不会被用到。这里一个文档中一个没有注明的是，<code>meta-user</code>总是会起作用，即使你指定了BSP，它也会覆盖掉里边的<code>meta-user</code>并重新打包。</p><p><code>packages</code>文件夹的结构和<code>sdbuild/packages</code>的结构类似，这两个目录下的每个文件夹对应一个个的组件，在编译过程中会被安装到RootFS中。安装过程主要是在<code>sdbuild/scripts/install_packages.sh</code>中进行。如果你需要增加组件，建议阅读此脚本和<code>sdbuild/packages/README.md</code>了解更多细节。</p><p>其他文件夹中如果存在Makefile文件，就会被认为是<code>Overlay</code>文件夹。在编译<code>pynq</code>本身时，<code>&lt;pynq_repo_dir&gt;/build.sh</code>脚本会试图进入这些文件夹，并挨个检查是否存在<code>.bit</code>、<code>.hwh</code>、<code>.xsa</code>等文件。这些文件夹不是必须的，主要是为用户提供一些针对该开发板的预置<code>Overlay</code>。</p><p><code>&lt;board_name&gt;.spec</code>文件描述了针对该开发板的各种配置和文件路径。它的格式如下所示：</p><figure class="highlight makefile"><figcaption><span>board_name.spec</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">ARCH_&lt;board_name&gt; := aarch64 <span class="comment"># Zynq的CPU架构，可以是aarch64或arm</span></span><br><span class="line">BSP_&lt;board_name&gt; := ... <span class="comment"># 开发板的BSP文件（如果有的话）</span></span><br><span class="line">BITSTREAM_&lt;board_name&gt; := ... <span class="comment"># 默认的比特流文件</span></span><br><span class="line">FPGA_MANAGER_&lt;board_name&gt; := 1</span><br><span class="line"></span><br><span class="line">STAGE4_PACKAGES_&lt;board_name&gt; := pynq ethernet ...</span><br></pre></td></tr></table></figure><p>注意这里的<code>board_name</code>要和文件夹的名字一致。</p><p>接下来我们可以依样画葫芦为自己的开发板配置这些文件了。<br>我在<a href="https://github.com/zhutmost/edgeboard/tree/master/pynq">edgeboard的仓库</a>中放置了针对EdgeBoard Lite的配置文件，如果需要的话你也可以参考。</p><h3 id="一把梭编译，赌人品"><a href="#一把梭编译，赌人品" class="headerlink" title="一把梭编译，赌人品"></a>一把梭编译，赌人品</h3><p>按照官方的流程，理论上我们可以开始进行漫长的编译了。不过我强烈建议你先阅读下后续的几个章节再开始编译（可以避免很多无谓的时间浪费）。</p><p>在<code>sdbuild</code>下运行：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ make BOARDDIR=&lt;edgeboard_repo_dir&gt;/edgeboard/pynq BOARDS=edgeboard-fz3a</span><br></pre></td></tr></table></figure><p>运气不错的话，我们能够在几个小时后获得最终的SD卡镜像<code>edgeboard-fz3a-2.7.0.img</code>，然后就可以将其烧写到SD卡上了。</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ sudo <span class="built_in">dd</span> <span class="keyword">if</span>=&lt;pynq_repo_dir&gt;/sdbuild/output/edgeboard-fz3a-2.7.0.img bs=1M of=/dev/mmcblk0 &amp;&amp; <span class="built_in">sync</span></span><br></pre></td></tr></table></figure><p>注意这里你的SD卡设备名可能不是<code>/dev/mmcblk0</code>，请务必再三确认，以免写入其他磁盘丢失数据。</p><h2 id="各种常见和不常见的Bug"><a href="#各种常见和不常见的Bug" class="headerlink" title="各种常见和不常见的Bug"></a>各种常见和不常见的Bug</h2><p>实践中，上一步十之八九会遇到各种奇奇怪怪的问题，然后报错退出。这里我没法给出一个万能方法，只能说“具体情况，具体分析”。记得多翻日志，多问谷歌。</p><p>我把各种我遇到的问题罗列于此，并提供了我的原因分析和解决方法。</p><h3 id="NodeJS安装时报错base-files-is-not-configured"><a href="#NodeJS安装时报错base-files-is-not-configured" class="headerlink" title="NodeJS安装时报错base_files is not configured"></a>NodeJS安装时报错<code>base_files is not configured</code></h3><p>在运行到<code>sdbuild/packages/jupyter/qemu.sh</code>时，它会用apt安装NodeJS（这是运行Jupyter Notebook必要的）。此时，apt安装无法完成，并出现以下报错：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">Setting up base-files (11ubuntu5) ...</span><br><span class="line">/bin/rmdir: failed to remove <span class="string">&#x27;/var/run&#x27;</span>: Directory not empty</span><br><span class="line">dpkg: error processing package base-files (--configure):</span><br><span class="line"> installed base-files package post-installation script subprocess returned error <span class="built_in">exit</span> status 1</span><br><span class="line">dpkg: dependency problems prevent configuration of bash:</span><br><span class="line"> bash depends on base-files (&gt;= 2.1.12); however:</span><br><span class="line">  Package base-files is not configured yet.</span><br><span class="line"></span><br><span class="line">dpkg: error processing package bash (--configure):</span><br><span class="line"> dependency problems - leaving unconfigured</span><br><span class="line">Errors were encountered <span class="keyword">while</span> processing:</span><br><span class="line"> base-files</span><br><span class="line"> bash</span><br><span class="line">No apport report written because the error message indicates its a followup error from a previous failure.</span><br><span class="line">E: Sub-process /usr/bin/dpkg returned an error code (1)</span><br></pre></td></tr></table></figure><p>它提示NodeJS在安装时需要访问一个名为<code>base-files</code>的组件，但是该组件在此时还没有完成“configure”。我们沿着这个信息往上追溯的话，会一直找到RootFS的初始化，此时该组件应当完成安装。</p><p>PYNQ采用Multistrap作为RootFS的初始化工具，它利用apt下载所需要的包并进行安装。<code>base-files</code>正是其中一个此时应当被安装的包，完整的包列表可以见<code>ubuntu/focal/aarch64/multistrap.config</code>。观察安装日志，可以最终定位到真正的错误原因：<code>base-files</code>的安装会用到<code>chmod</code>，这要求另一个名为<code>base-passwd</code>的包必须比它先完成“configure”，否则<code>base-files</code>的安装就会失败。简而言之，就是<code>base-files</code>依赖<code>base-passwd</code>。</p><p>那么问题来了，为什么RootFS初始化时部分包安装失败后不会报错呢？原因在<code>sdbuild/scripts/create_rootfs.sh</code>脚本中如下的两行代码抑制了<code>postinst1.sh</code>和<code>postinst2.sh</code>两个脚本的报错：</p><figure class="highlight bash"><figcaption><span>create_rootfs.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$dry_run</span> sudo -E <span class="built_in">chroot</span> <span class="variable">$target</span> bash postinst1.sh</span><br><span class="line">... <span class="comment"># other stuff</span></span><br><span class="line"><span class="variable">$dry_run</span> sudo -E <span class="built_in">chroot</span> <span class="variable">$target</span> bash postinst2.sh</span><br></pre></td></tr></table></figure><p>因此此处即使发生安装失败，程序也会继续执行下去。</p><p>更为本质的一个问题是为什么dpkg无法检测到上述两个软件包之间的依赖关系。这已经超出了PYNQ的范畴，根据Debian社区的意思大体上可以这么理解：<code>base-files</code>和<code>base-passwd</code>都是属于Essential的包，理论上它们都是必装的，因此就没有设置依赖关系。如果我们为这些必装的组件之间相互设置依赖关系的话，会陷入循环依赖的地狱。那么在安装时它们之间发生依赖冲突怎么办呢？这个问题至少在2011年就<a href="https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=612426">有人提出过</a>，社区的结论是这个问题并不常见（多数时候<code>base-passwd</code>总比<code>base-files</code>先完成“configure”），所以不妨依靠玄学。他们认为这个问题在新的Multistrap版本上不会出现，然而并不。</p><p>这里我的解决方法是手工指定<code>dpkg --configure</code>的顺序，将<code>sdbuild/scripts/create_rootfs.sh</code>的<code>postinst1.sh</code>部分中原先的<code>dpkg --configure -a</code>修改成：</p><figure class="highlight bash"><figcaption><span>create_rootfs.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 先完成base-passwd的configure</span></span><br><span class="line">dpkg --configure gcc-10-base libcrypt1 libc6 libgcc-s1 libdebconfclient0 base-passwd</span><br><span class="line"><span class="comment"># 再完成其他组件的configure</span></span><br><span class="line">dpkg --configure -a</span><br></pre></td></tr></table></figure><h3 id="python2-7-minimal安装失败"><a href="#python2-7-minimal安装失败" class="headerlink" title="python2.7-minimal安装失败"></a><code>python2.7-minimal</code>安装失败</h3><p>与上个问题类似，有时会出现<code>python2.7-minimal</code>这个包的<code>configure</code>失败。这个问题本身不是很严重，因为<code>postinst1.sh</code>和<code>postinst2.sh</code>两个脚本会各执行一遍<code>dpkg --configure -a</code>，因此第一遍中极少量没成功安装的包会在第二遍中完成安装（比如<code>cups-pk-helper</code>这个包经常如此）。然而，因为有大量包依赖于<code>python2.7-minimal</code>，一旦它安装失败后，一连串的包会一同安装失败，然后安装程序就崩了。</p><p>这里可以从报错信息中观察到，安装失败的原因是它的<code>postinst</code>脚本中用到了<code>awk</code>，然而此时<code>awk</code>这个命令还未安装。解决方法也和上个问题类似，即手工指定<code>dpkg --configure</code>的顺序，确保提供<code>awk</code>命令的包比<code>python2.7-minimal</code>先完成<code>configure</code>。有很多包都提供了<code>awk</code>命令，我这里选择了<code>mawk</code>。</p><figure class="highlight bash"><figcaption><span>create_rootfs.sh</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dpkg --configure &lt;... 其他需要提前`configure`的包&gt; mawk</span><br><span class="line">dpkg --configure -a</span><br></pre></td></tr></table></figure><h3 id="无法从SD卡启动，找不到RootFS"><a href="#无法从SD卡启动，找不到RootFS" class="headerlink" title="无法从SD卡启动，找不到RootFS"></a>无法从SD卡启动，找不到RootFS</h3><p>这个问题深究起来非常复杂，现象是烧写完SD卡上板卡后，无法完成开机，屏幕&#x2F;串口会显示内核错误。其中括号里的数字我这边是<code>179,2</code>和<code>179,10</code>两种情形之一（我没有彻底弄清楚这俩数字的含义）。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Kernel Panic - not syncing: VFS: Unable to mount root fs on unknown-block(179,10)</span><br></pre></td></tr></table></figure><p>关于SD卡的一系列bug都会引起这个报错。首先请确保SD卡烧写成功，烧写完成后可以在Ubuntu中挂载并尝试打开检查一下，如果不能正常打开的话重新烧写下。然后请参考以下几点依次排查。因为该报错的原因很多，我这里可能列举不全，见谅。</p><h4 id="使用dd烧写时块大小不合适"><a href="#使用dd烧写时块大小不合适" class="headerlink" title="使用dd烧写时块大小不合适"></a>使用<code>dd</code>烧写时块大小不合适</h4><p>RootFS分区的文件系统是Ext4，它在开机时会检查分区大小，因此如果在<code>dd</code>时使用过大的块大小（block size，也就是<code>bs=...</code>参数），就会无法通过分区大小的检查。</p><p>比如用4M的块大小烧写镜像的话（即<code>sudo dd bs=4M if=... of=...</code>），开机就会保错。在我这使用1M的块大小是正常的，具体命令可以看前文。</p><h4 id="SD卡的写保护"><a href="#SD卡的写保护" class="headerlink" title="SD卡的写保护"></a>SD卡的写保护</h4><p>这个问题似乎是来自于很多人使用了淘宝购买EdgeBoard FZ3A开发板时店家提供的所谓“Vivado参考设计”。这个参考设计中关于SD卡的配置存在错误，它打开了SD卡槽的写保护引脚。但是据<a href="https://whycan.com/t_3467.html">WhyCan Forum社区的文章</a>指出，EdgeBoard的PCB设计中去掉了这一引脚。因此，我们稳妥起见，可以在设备树中禁用掉写保护功能。</p><p>如前文所述，PYNQ为我们提供了一个修改设备树的接口，就是<code>boards/&lt;board_name&gt;/petalinux_bsp</code>文件夹。我们先在相应目录下创建一个设备树文件：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">mkdir</span> -p &lt;pynq_repo_dir&gt;/boards/&lt;board_name&gt;/petalinux_bsp/meta-user/recipes-bsp/device-tree/files</span><br><span class="line">❯ <span class="built_in">cd</span> &lt;pynq_repo_dir&gt;/boards/&lt;board_name&gt;/petalinux_bsp/meta-user/recipes-bsp/device-tree/files</span><br><span class="line">❯ <span class="built_in">touch</span> system-user.dtsi</span><br></pre></td></tr></table></figure><p>然后对sdhci1节点（对应于PS_SD1，即我们的SD卡槽）进行修改。完成以后，你的<code>system-user.dtsi</code>文件应该长这个样子：</p><figure class="highlight plaintext"><figcaption><span>system-user.dtsi</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">/include/ &quot;system-conf.dtsi&quot;</span><br><span class="line">/ &#123; /*根节点，这里保持不变*/</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">&amp;sdhci1 &#123;</span><br><span class="line">  status = &quot;okay&quot;;</span><br><span class="line">  max-frequency = &lt;50000000&gt;;</span><br><span class="line">  no-1-8-v; /*我其实不太理解这行的作用，但反正一出兼容性问题，大家就会写这个*/</span><br><span class="line">  disable-wp; /*关掉写保护功能*/</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>理论上如果使用我自己做的Board Files里的Zynq Preset，是不会遇到这个问题的（不过我没试，重新编译太费时了）。</p><h4 id="Boot参数中设置了错误的root分区位置"><a href="#Boot参数中设置了错误的root分区位置" class="headerlink" title="Boot参数中设置了错误的root分区位置"></a>Boot参数中设置了错误的<code>root</code>分区位置</h4><p>PYNQ默认总是从<code>/dev/mmcblk0</code>（这个路径是PYNQ上的，不是你的宿主Ubuntu上的）启动系统，即它如果它有多个SD外设的话，SD卡要连在<code>PS_SD0</code>上。不幸的是，EdgeBoard还真的有两个SD设备，一个是我们的TF卡槽，另一个是一颗eMMC Flash芯片。默认情形下，PYNQ总是会尝试从后者启动，而我们的系统实际存放在SD卡上。</p><p>PetaLinux的Boot参数是通过设备树中的<code>/chosen/bootargs</code>条目进行配置的。默认情况下，最后镜像使用的设备树中该条目会是这样的（每个字段的先后顺序不重要）：</p><figure class="highlight plaintext"><figcaption><span>system-user.dtsi</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bootargs = &quot;root=/dev/mmcblk0p2 rw earlyprintk rootfstype=ext4 rootwait devtmpfs.mount=1 uio_pdrv_genirq.of_id=\&quot;generic-uio\&quot; clk_ignore_unused&quot;;</span><br></pre></td></tr></table></figure><p>但我们希望其中的字段<code>root=/dev/mmcblk0p2</code>变成<code>root=/dev/mmcblk1p2</code>。直觉上，首先想到的是很上文一样修改<code>system-user.dtsi</code>文件，从而影响最终生成的设备树。实验会告诉你完全不起作用，最后输出也就是实际使用的设备树里还是上面这行默认值。这里大家就会遇到PYNQ这个编译流程设计的很糟糕的一点：<code>system-user.dtsi</code>这个文件中的只有一部分会起作用，至于想弄清哪部分，要么做实验，要么看懂编译源代码。比如上面对<code>&amp;sdhci1</code>节点的修改就能生效，对<code>/chosen/bootargs</code>对修改就不起作用。</p><p>生成设备树是制作BSP文件的中一部分，接下来我们来弄清楚PYNQ是如何生成最终的BSP文件的。我们先考虑用户没有提供预编译的BSP文件的情形，此时PYNQ内部会依次做这些事：</p><ol><li>建立一个空的PetaLinux项目</li><li>拷贝用户的<code>petalinux_bsp/meta-user</code>到该项目下；</li><li>读入硬件配置即<code>petalinux_bsp/hardware_project</code>中的XSA文件，生成Config文件；</li><li>构建并打包成BSP文件；</li><li>利用上一步获得的BSP文件建立一个新的PetaLinux项目；</li><li>直接在脚本中修改Config文件，加入一些配置；</li><li>重新运行<code>petalinux-config</code>生成新的Config文件；</li><li>开始各种build，最终生成我们需要的BOOT.bin。</li></ol><p>其中步骤1、2、3、4在<code>sdbuild/scripts/create_bsp.sh</code>脚本中进行，步骤5、6、7、8在<code>sdbuild/Makefile</code>中进行。如果用户指定了预编译的BSP文件，就把上文中的第1步换成“利用用户提供的BSP文件建立一个新的PetaLinux项目”。这里最令人困惑的地方是，为什么要进行两次“create-config-build”的流程，至少我没有看出它这么做的必要性。这样一通操作之后，用户在<code>petalinux_bsp/meta-user</code>的子目录下的<code>system-user.dtsi</code>文件中修改的一些设备树节点（对应上文步骤2），会在步骤6中被新引入的一些设备树文件冲刷掉。步骤6通过<code>CONFIG_USER_LAYER_0</code>这一设置混入了一些新的设备树文件，这些额外的设备树文件位于<code>sdbuild/boot/meta-pynq/recipes-bsp/device-tree</code>。就Boot参数而言，这里边的<code>pynq_bootargs.dtsi</code>文件提供了前述的默认<code>/chosen/bootargs</code>。因此无论我们在<code>system-user.dtsi</code>文件中如何修改<code>/chosen/bootargs</code>，最终都会被覆盖掉。因此，我们的解决方案很简单，修改下该文件，将其中的<code>root=/dev/mmcblk0p2</code>变成<code>root=/dev/mmcblk1p2</code>。因为这个文件只有几行，改动也很小，我就不把代码贴出来了。</p><p>除了修改<code>pynq_bootargs.dtsi</code>，我们还需要修改<code>sdbuild/Makefile</code>，将下面这行代码中的<code>mmcblk0p2</code>变成<code>mmcblk1p2</code>。</p><figure class="highlight bash"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_SDROOT_DEV=&quot;/dev/mmcblk0p2&quot;&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br></pre></td></tr></table></figure><p>我这里提供另一个有趣的思路，<code>sdhci0</code>和<code>sdhci1</code>在设备树文件中是俩alias，我们可以在设备树中交换它们的值（<code>/amba/mmc@ff160000</code>和<code>/amba/mmc@ff170000</code>）。不过我没有做过实验。</p><!-- 标准的PetaLinux项目中，我们通过`petalinux-config`的GUI配置界面 --><h3 id="UART串口不工作"><a href="#UART串口不工作" class="headerlink" title="UART串口不工作"></a>UART串口不工作</h3><p>EdgeBoard FZ3A有两个UART串口，一个是BT1120连接件的一部分，另一个转成了USB接口。我们用来连接电脑进行交互的串口，显然希望是后者。和前面SD卡的情况相似，PYNQ默认PS_UART0作为输出串口，而我们实际想要的是PS_UART1。解决这个问题的方法很简单，在上面修改<code>CONFIG_SUBSYSTEM_SDROOT_DEV</code>的那行后面加上以下几行：</p><figure class="highlight bash"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_PMUFW_SERIAL_PSU_UART_1_SELECT=y&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_FSBL_SERIAL_PSU_UART_1_SELECT=y&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_ATF_SERIAL_PSU_UART_1_SELECT=y&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_SERIAL_PSU_UART_1_SELECT=y&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;CONFIG_SUBSYSTEM_PRIMARY_SD_PSU_SD_1_SELECT=y&#x27;</span> &gt;&gt; $$(PL_CONFIG_<span class="variable">$1</span>)</span><br></pre></td></tr></table></figure><h3 id="dash-preinst找不到"><a href="#dash-preinst找不到" class="headerlink" title="dash.preinst找不到"></a><code>dash.preinst</code>找不到</h3><p>RootFS的编译脚本（即<code>create_rootfs.sh</code>）会在前面提到的<code>postinst1.sh</code>和<code>postinst2.sh</code>两个脚本执行中提示<code>dash.preinst</code>执行失败，原因是<code>/var/lib/dpkg/info/dash.preinst</code>找不到。该错误的原因仅仅是上游已经把<code>dash.preinst</code>这个脚本删除了（可参考<a href="https://unix.stackexchange.com/questions/558844/no-var-lib-dpkg-info-dash-preinst-in-buster">此文</a>）。因此这里执行该脚本的三行代码都是多余的，直接删除即可。即使不删除，它们也应当不会引起其他异常（除了在终端里输出一些错误信息）。</p><h3 id="RootFS分区磁盘容量不足"><a href="#RootFS分区磁盘容量不足" class="headerlink" title="RootFS分区磁盘容量不足"></a>RootFS分区磁盘容量不足</h3><p>PYNQ在编译的最后，会对最终的镜像的RootFS分区进行扩容。扩容主要是增加一些用户空间，以及给操作系统本身腾出一些地方放临时文件。扩容操作是在<code>sdbuild/scripts/resize_umount.sh</code>脚本中进行（别问我为什么文件名中unmount拼写错了，源代码如此）。PYNQ的开发者很可能是为了尽量使最终镜像小于8GB，所以只额外扩容了300MB。</p><p>很不幸的是，这300MB实在是捉襟见肘，经常开完机就用得七七八八了。极端情况下，可能不足以支撑Jupyter成功运行，现象是能够ssh访问，但浏览器完全打不开Jupyter。排查方法是，上电后通过ssh进入板上的操作系统，执行<code>df</code>，观察<code>/</code>分区的磁盘占用情况。</p><p>我的SD卡是64GB的，因此，我直接修改了<code>resize_umount.sh</code>脚本，将扩容空间从300MB改成了3000MB。你可以根据你的SD卡容量自由发挥，当然没必要太大，否则烧写SD卡会变得很慢。具体到代码上，在该脚本中找到下面一行代码，把其中的300改成任意你想要的数字。</p><figure class="highlight bash"><figcaption><span>Makefile</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">new_size=$(( <span class="variable">$used_size</span> + (<span class="number">300</span> * <span class="number">1024</span>) ))</span><br></pre></td></tr></table></figure><h3 id="各种文件下载失败"><a href="#各种文件下载失败" class="headerlink" title="各种文件下载失败"></a>各种文件下载失败</h3><p>多数都是网络环境的问题，可以先阅读下一节。如果还是解决不了的话，请联系公司的IT工程师协助解决。</p><h2 id="Speedup！编译提速"><a href="#Speedup！编译提速" class="headerlink" title="Speedup！编译提速"></a>Speedup！编译提速</h2><p>在我的破笔记本上，完整的一次PYNQ流程需要整一个下午，中间还需要多次输入管理员密码。因为我们很难一次成功，所以需要不断地重新进行编译流程，所以我们总希望整个编译能够进行地快一些。接下来我们开始着手加速编译流程。</p><h3 id="跳过输入管理员密码"><a href="#跳过输入管理员密码" class="headerlink" title="跳过输入管理员密码"></a>跳过输入管理员密码</h3><p>PYNQ编译中会频繁使用<code>sudo</code>命令，需要我们不断地输入密码，否则程序就一直卡在那等待。Ubuntu默认两次<code>sudo</code>的时间间隔超过15分钟左右就要重新输入密码，我们可以把这个时间延长一些（比如这里我延长到了2小时）。</p><p>首先在<code>/etc/sudoers</code>中找到如下一行。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults    env_reset</span><br></pre></td></tr></table></figure><p>将它改成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Defaults    env_reset,timestamp_timeout=120</span><br></pre></td></tr></table></figure><h3 id="为Multistrap更换下载源"><a href="#为Multistrap更换下载源" class="headerlink" title="为Multistrap更换下载源"></a>为Multistrap更换下载源</h3><p>Multistrap利用apt下载各种需要的包来构建RootFS。默认情况下，apt会从官方ports源（<code>http://ports.ubuntu.com/ubuntu-ports</code>）下载文件，时间很长且经常失败。换源的方法非常方便，直接在编译开始前声明<code>PYNQ_UBUNTU_REPO</code>环境变量即可。例如换成清华源：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">export</span> PYNQ_UBUNTU_REPO=http://mirrors.tuna.tsinghua.edu.cn/ubuntu-ports</span><br></pre></td></tr></table></figure><p>注意这里必须是<code>http</code>而不是<code>https</code>。</p><h3 id="为CrossTool-NG建立本地缓存"><a href="#为CrossTool-NG建立本地缓存" class="headerlink" title="为CrossTool-NG建立本地缓存"></a>为CrossTool-NG建立本地缓存</h3><p>CrossTool-NG每次运行时会从云端下载很多包（主要是各种源代码）。根据其文档的指示，我们可以建立一个本地的缓存文件夹。当需要下载的包本地已经缓存时，它就会跳过下载，从而节省时间。CrossTool-NG的配置文件在<code>sdbuild/packages/gcc-mb/samples/&lt;compile_targets&gt;/crosstool.config</code>，在其最后加上两行：</p><figure class="highlight plaintext"><figcaption><span>crosstool.config</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CT_SAVE_TARBALLS=y</span><br><span class="line">CT_LOCAL_TARBALLS_DIR=&lt;somewhere_to_put_downloaded_files&gt;</span><br></pre></td></tr></table></figure><p>注意请在运行前保证该路径是个文件夹，且具有读写权限。</p><h3 id="为PetaLinux建立本地SSTATE缓存"><a href="#为PetaLinux建立本地SSTATE缓存" class="headerlink" title="为PetaLinux建立本地SSTATE缓存"></a>为PetaLinux建立本地SSTATE缓存</h3><p>首先去<a href="https://www.xilinx.com/support/download/index.html/content/xilinx/en/downloadNav/embedded-design-tools/2020-2.html">Xilinx官网</a>下载sstate-cache文件。注意版本要和PetaLinux保持一致（本文中我们用的是2020.2）。</p><p>因为EdgeBoard FZ3A板载的Zynq芯片是ARM64架构，因此为了节约空间，就只下载“aarch64 sstate-cache”和“downloads”两个包（加起来也超过60GB了）。然后我们将它们解压缩，并把路径添加到<code>petalinux_bsp/meta-user/conf/petalinuxbsp.conf</code>：</p><figure class="highlight bash"><figcaption><span>petalinuxbsp.conf</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DL_DIR = <span class="string">&quot;&lt;sstate_extract_dir&gt;/2020.2/downloads&quot;</span></span><br><span class="line">SSTATE_DIR = <span class="string">&quot;&lt;sstate_extract_dir&gt;/2020.2/sstate-cache/aarch64&quot;</span></span><br></pre></td></tr></table></figure><h3 id="删除boards目录下Pynq-Z2以外的开发板"><a href="#删除boards目录下Pynq-Z2以外的开发板" class="headerlink" title="删除boards目录下Pynq-Z2以外的开发板"></a>删除<code>boards</code>目录下Pynq-Z2以外的开发板</h3><p>因为我们的编译目标是EdgeBoard FZ3A，所以<code>boards</code>目录下的<code>Pynq-Z1</code>、<code>Pynq-Z2</code>、<code>ZCU104</code>三个目录对我们来说就是多余的。然而PYNQ在编译过程中会遍历<code>boards</code>目录下的各个开发板并试图生成比特流文件。其中<code>Pynq-Z2</code>的输出会在<code>pynq</code>自身编译时用到，另外两个开发板的相关文件的编译纯属是浪费时间（关键是这步还特别费时），我怀疑这是个bug。因此，我们可以将<code>Pynq-Z1</code>、<code>ZCU104</code>两个文件夹删除。</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">❯ <span class="built_in">cd</span> &lt;pynq_repo_dir&gt;</span><br><span class="line">❯ <span class="built_in">rm</span> -rf boards/Pynq-Z1 boards/ZCU104</span><br></pre></td></tr></table></figure><p>完成之后，务必要提交到本地的Git版本历史中，否则不起作用（这是因为作者用<code>git clone</code>代替了<code>cp</code>）。</p><h3 id="跳过boards-Pynq-Z2中各个Overlay生成比特流"><a href="#跳过boards-Pynq-Z2中各个Overlay生成比特流" class="headerlink" title="跳过boards/Pynq-Z2中各个Overlay生成比特流"></a>跳过<code>boards/Pynq-Z2</code>中各个<code>Overlay</code>生成比特流</h3><p><code>pynq</code>作为一个Python的包，在编译过程中是要和其他packages一起安装到镜像中的。进行这一步时，它会将Pynq的本地repo先复制到<code>sdbuild/build/PYNQ</code>中，然后再运行其中的<code>build.sh</code>。观察这个脚本，我们可以看到PYNQ在编译<code>Pynq-Z2/logictools</code>和<code>Pynq-Z2/base</code>两个<code>Overlay</code>文件夹时，会先检查其中是否已存在同名的<code>.bit</code>、<code>.hwh</code>、<code>.xsa</code>文件，存在的话就跳过生成比特流的过程（即综合、布局布线等）。因此，我们可以先按照正常流程<code>make BOARDDIR=... BOARDS=...</code>，然后把生成的相关文件拷贝到原始的<code>boards/Pynq-Z2</code>目录中的对应文件夹下：</p><figure class="highlight bash"><figcaption><span>Terminal</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 复制.xsa文件，.bit/.hwh文件类似处理</span></span><br><span class="line">❯ <span class="built_in">cp</span> &lt;pynq_repo_dir&gt;/sdbuild/build/PYNQ/boards/Pynq-Z2/logictools/logictools.xsa &lt;pynq_repo_dir&gt;/boards/Pynq-Z2/logictools/</span><br><span class="line">❯ <span class="built_in">cp</span> &lt;pynq_repo_dir&gt;/sdbuild/build/PYNQ/boards/Pynq-Z2/base/base.xsa &lt;pynq_repo_dir&gt;/boards/Pynq-Z2/base/</span><br></pre></td></tr></table></figure><p>注意这里的路径，是从<code>sdbuild/build</code>中的<code>PYNQ</code>复制到原始的<code>PYNQ</code>。和前面一样，要提交到Git版本历史中才会生效。</p><p>另外，经过实验证明，这里<code>.xsa</code>和<code>.bit</code>文件需要是同一次编译中产生，否则会发生一些奇怪且难以定位的错误。</p><h2 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h2><p>搭建这个个人博客也有几年了，本想闲暇时写些技术文章，但没能持之以恒地保持输出。中间也曾断断续续写过一些论文阅读笔记，但都没有坚持下来。一方面是因为总担心自己粗浅的专业认识贻笑大方，另一方面是实验室的项目也确实不太合适作为写作素材，便一直没有动笔。EdgeBoard的事情我在去年COVID疫情期间动工后就一直搁置了，结果发现最近有不少人关心这个事情，就花了些时间算是给它画了个句号。我也以此为契机，提起了笔记录下整个过程。希望能够对大家有所帮助。</p><p><a style="background-color:black;color:white;text-decoration:none;padding:4px 6px;font-size:12px;line-height:1.2;display:inline-block;border-radius:3px" href="https://unsplash.com/photos/ZrPFrPLgC-o" target="_blank" rel="noopener noreferrer" title="An Alpine Valley, the Matterhorn in the Distance. Artist: John Ruskin"><span style="display:inline-block;padding:2px 3px"><svg xmlns="http://www.w3.org/2000/svg" style="height:12px;width:auto;position:relative;vertical-align:middle;top:-1px;fill:white" viewBox="0 0 32 32"><path d="M20.8 18.1c0 2.7-2.2 4.8-4.8 4.8s-4.8-2.1-4.8-4.8c0-2.7 2.2-4.8 4.8-4.8 2.7.1 4.8 2.2 4.8 4.8zm11.2-7.4v14.9c0 2.3-1.9 4.3-4.3 4.3h-23.4c-2.4 0-4.3-1.9-4.3-4.3v-15c0-2.3 1.9-4.3 4.3-4.3h3.7l.8-2.3c.4-1.1 1.7-2 2.9-2h8.6c1.2 0 2.5.9 2.9 2l.8 2.4h3.7c2.4 0 4.3 1.9 4.3 4.3zm-8.6 7.5c0-4.1-3.3-7.5-7.5-7.5-4.1 0-7.5 3.4-7.5 7.5s3.3 7.5 7.5 7.5c4.2-.1 7.5-3.4 7.5-7.5z"></path></svg></span><span style="display:inline-block;padding:2px 3px">photoed by Birmingham Museums</span></a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;PYNQ是我很喜欢的一个FPGA开源工具。它将Zynq上的各种硬件资源用Python封装了起来，允许用户通过Jupytor Notebook远程调试FPGA。将PYNQ移植到Baidu EdgeBoard上是我去年在COVID疫情期间开的坑（具体请参看&lt;a href=&quot;https://github.com/zhutmost/edgeboard&quot;&gt;我的GitHub&lt;/a&gt;），但中间遇到的小问题有点多，便一直没有完全填上。我最近抽出了些时间重新拾起了这个事情，就顺便把整个过程和遇到的问题都记录下来，以飨后来者。&lt;/p&gt;
&lt;p&gt;相关源代码已开源至&lt;a href=&quot;https://github.com/zhutmost/edgeboard&quot;&gt;Github&lt;/a&gt;，预编译PYNQ镜像文件我也已上传至&lt;a href=&quot;https://www.aliyundrive.com/s/6biJpMiKrpD&quot;&gt;阿里云盘&lt;/a&gt;。因为设备有限，我没有为这个镜像进行所有外设的上板测试。如果你发现了任何问题，欢迎和我联系。&lt;/p&gt;</summary>
    
    
    
    <category term="Engineering" scheme="https://zhutmost.com/categories/Engineering/"/>
    
    
    <category term="FPGA" scheme="https://zhutmost.com/tags/FPGA/"/>
    
    <category term="PYNQ" scheme="https://zhutmost.com/tags/PYNQ/"/>
    
  </entry>
  
</feed>
